=== components/Output 1 ===

$12242923444593* Output


=== levels/RAM ===

$17967666262990* In this test, first copy from input 32 times and store these values. After you have loaded the 32 values, output them in the same order as you got them. Outputting before you have read all the inputs will fail the level.
$13520918982355* Add a ram block, so the computer can address 256 additional bytes of memory. You need a way to decide which of the 256 bytes inside the ram we are addressing. Select a register and wire it up, so its value always selects the RAM address. When you later want to load or save to the RAM, you will have to first copy the RAM address to this register.


=== levels/byte_less_i ===

$16755383054285* [center]Determine if the first input is less than the second.[/center]
$19006843777401* Create a circuit that outputs [ON] when the first input is less than the second. Interpret the bytes as being [color=#dd6576]SIGNED[/color].
$46083799633716* Is {input_1} less than {input_2}?


=== trans/level_registers_description ===

$73800316874022* [center]Create the schematic that matches the code specifications[/center]


=== components/Output1Car ===

$12896765714603* Carry


=== trans/level_circumference_description ===

$20154743351442* [center]Add conditions to the calculation codes[/center]


=== components/FullAdder ===

$57559382166174* Adds 3 bits and outputs the sum and the carry
$77669928463861* Full Adder


=== misc/options ===

$49251062339706* options


=== misc/ide_delete_program ===

$87279416580516* Yes


=== levels/turing_complete ===

$15326252036920* Before, only code could influence memory, now memory must influence code. With the addition of conditional logic, our computer can run any algorithm, and calculate anything calculable.
$16583885726240* Yes you did it! I thought you were just this odd looking hairless ape creature, but you actually built a real computer! Amazing.
$10510746154639* At tick 1 the program should load address 1.
$10317244906317* No program found
$14587485007736* Until this point all possible programs have been confined to running in order byte by byte.
$19649119273248*
The final thing we need to add is a mechanism for changing the program counter through [INSTRUCTIONS] when certain conditions are met.

When the two largest bits are [ON][ON], we are in condition mode. In condition mode, the value in REG 3 is compared against the conditions defined by the lowest 3 bits in the instruction. If the condition is true, we overwrite the counter to the value in REG 0.
Conditionally changing the counter means we can skip [INSTRUCTIONS] based on conditions or have [INSTRUCTIONS] run in a loop.

Conditions:
[OFF] [OFF] [OFF] Never
[OFF] [OFF] [ON] If [color=#e49f44]REG 3[/color] = 0
[OFF] [ON] [OFF] If [color=#e49f44]REG 3[/color] < 0
[OFF] [ON] [ON] If [color=#e49f44]REG 3[/color] ≤ 0 
[ON] [OFF] [OFF] Always
[ON] [OFF] [ON] If [color=#e49f44]REG 3[/color] ≠ 0 
[ON] [ON] [OFF] If [color=#e49f44]REG 3[/color] ≥ 0
[ON] [ON] [ON] If [color=#e49f44]REG 3[/color] > 0

These conditions correspond to the condition component that was saved in the component factory.


=== components/Neg16 ===

$17253409670931* Negate
$57512333327652* Bitwise negates an input


=== components/Input 1 ===

$12746117288689* Input


=== levels/Second Tick ===

$14355963067874* Output [ON] on the second tick only.
$17526582195506* As you know these tests culminate in building a functioning computer.
$15726318553190* This is the main reason we don't eat you afterwards.
$19277843280528*
 [color=#b72d41][b]TIP:[/b][/color] 
You can select a component with its pins by double clicking it
$15296208528991* Species that are capable of finishing are considered sentient by law.


=== trans/manual_text_console ===

$39093856809104*
The console component is a 80x24 [color=#dd6576][url=RGB color]ASCII[/url][/color] display. It must be linked to a memory source through the component link button:
 [img=200]dialogue/manual/Console/link_state.png[/img]

Updating the linked memory will then update the visuals on the console. In standard non color mode, each byte in the memory component determines what the corresponding character on the screen will be. However, the first character position can be offset by using the input pin on the console. This is for example useful when implementing scrolling.

The console also has a color mode that can be toggled on in the panel:
[img=125]dialogue/manual/Console/color_mode.png[/img]

In this mode each character has an additional 3 byte background and 3 byte foreground [color=#dd6576][url=RGB color]RGB color[/url][/color] for a total of 7 bytes of data per character. However, each character is 8 byte aligned, which is more convenient when you set your RAM or ROM to 64 bit width addressing. Also, you may keep the character indexes the same when changing your schematic from non color to color mode, by change the bitwidth of the RAM or ROM from 8 to 64 at the same time. 

In color mode the lowest byte is the character, the next 3 bytes are the font color and the following 3 bytes are the background color.





=== levels/component_factory ===

$14665712485657* This custom component can not be used as it has no area.
$17077079648771* Components can be added, renamed or deleted using the level save system.
$19551383617326*
Welcome to the component factory, the circuits you create in here will be usable as components in architectures.
The circuitry you create defines the behavior of the component and the layout defines its shape.
$12516102012088* This component has no area and will not be usable in levels. Place components on the map to give it area.
$14712417427860* Since this level is a tool and not a challenge, you can go to the level map and continue on when you want.
$15549447390000* 2 input/output components are in the same square. The custom component will be unusable since 2 pins can't overlap.


=== misc/ui_panel/outputs ===

$29350436761480* OUTPUTS


=== components/Register32 ===

$65405398199118* 32 bit memory
$22031255978461* 32 Bit Register


=== trans/level_multiply_description ===

$28761562806647* [center]Pairwise AND together each bit[/center]


=== misc/instr_delete ===

$91861509153454* Delete


=== trans/manual_the_robot ===

$92896462984546* The robot


=== trans/level_bit_inverter_RichTextLabel2 ===

$67127889187842*
[right][color=#e49f44]Value
Invert[/color]
Desired output
Current output[/right]


=== trans/level_conditions_description ===

$62540112577327* [center]When the value meets the condition output [img]dialogue/on.png[/img], output [img]dialogue/off.png[/img] otherwise.[/center]


=== components/64Ram ===

$63410290483563* Low gate cost but slow memory
$78790416494254* RAM


=== trans/manual_text_top_the_robot ===

$50801318216470* The screen shows the robot and his surroundings.


=== trans/ide_memory_address ===

$94594171568769* [center]Linked components[/center]


=== components/Nand16 ===

$63870790225686* Bitwise NAND two values
$56507506086622* 8 Bit NAND


=== misc/ui_comment ===

$69987793052607* Wire comment (Click on wire)


=== levels/delay_level ===

$19986989895202*
All components have a delay. And in a circuit, the total delay is determined by the slowest path. This means you normally want to put things in parallel.
In this level you must prove that you understand this concept.
$11246430085016* Note, you can see the delay path by clicking the hour glass in the upper right corner.
$12817338693402* The delay of any component is ultimately derived from the delay of the basic gates, which have a delay of 2. Build a circuit with a delay of 6 and a gate cost of 5.
$17854168097855* Check


=== misc/specification_dialogue ===

$93899425142858* Copy from {from} to {to}
$92046368194170* Condition
$39935096343723* Never
$52961346176405* {condition} copy [color=#dd6576]REG 0[/color] to counter
$18833529038946* When [color=#2b8738]result[/color] {condition}
$10141348037745* Immediate: {nr}
$98983752580592* Copy
$25145891843959* Always
$53665446068319* UNUSED
$26521666422399* Calculate
$54909668901048* Immediate


=== components/Mul16 ===

$49880767097125* Multiplies two inputs
$62247409328063* Multiply


=== components/Decoder2 ===

$25937877347447* Toggles between four outputs
$21727998752868* 2 Bit decoder


=== trans/level_negative_numbers_test_5 ===

$68419648206312* [center]Representation[/center]


=== components/Output1z ===

$31478630391268* Only outputs if the switch pin is [ON]
$84656390009725* Switched Output


=== trans/manual_text_assembly ===

$54465324391961*
You can use a mix of assembly codes and numbers to set the bytes. Assembly codes are just synonyms for a bit pattern. For example, instead of typing 196 for "add", this code can be named "add" directly, simplifying reading and writing code. 

Comments can be added using "#". 
[img]dialogue/comment.png[/img]

Additionally, the [color=#c54d5e]CONST[/color] keyword can be used to name a value within a specific program. 
[img]dialogue/const.png[/img]

[color=#c54d5e]LABEL[/color] assigns a name to the byte offset of the line it was inserted on. This is especially useful for naming jump destinations.
[img]dialogue/label.png[/img]

You can add, subtract, multiply, integer divide, modulo, OR, AND or XOR values together using +, -, *, /, %, |, & or ^ respectively.

Breakpoints can be added by clicking to the left of a line number. The program will automatically pause at breakpoints when running.
[img]dialogue/breakpoint.png[/img]

Breakpoints can also be added to any of the linked components, pausing the program when that state is changed. Click on the state and you will see the red dot.
[img]dialogue/breakpoint_state.png[/img]

Finally, values can be specified in binary with the prefix 0b (so 5 could be 0b0101) and hex with the prefix 0x (so 15 would be 0x0f)


=== trans/options_pipette_wire ===

$96339976117958* Wire pipette


=== misc/add_assembly_64bit ===

$33233688912123* [center]Add assembly code[/center]


=== trans/level_complete_wire_comments ===

$92673421413755*
[b]Wire comments[/b]
[color=#cccccc][i]Add comments to your wires.[/i][/color]


=== components/Mux ===

$11168613697835* Toggles between two values
$22167405631310* 8 Bit Mux


=== trans/level_byte_adder_question3 ===

$88075700159266*
[right]Carry IN
Byte 1
Byte 2[/right]


=== components/Switch32 ===

$70717074742809* 32 Bit Switch
$93061034213009* Toggles a value


=== components/Or16 ===

$76807373575014* Bitwise OR two values
$62695381407925* 16 Bit OR


=== components/SegmentDisplay ===

$56761198694928* Good for displaying numbers
$90582128204153* 7 Segment Display


=== misc/files_preview ===

$15827374884671* To parent folder
$14135691870941* Last edit\nSchematics
$32645745463577* Used in components
$19184997172542* Used in architectures
$36200352866864* Last edit


=== trans/schematic_new_folder_name ===

$86236104278688* New folder


=== levels/Nor GATE ===

$11362258372706*
Most creatures on Earth are aggressive and do not know how to focus.

To succeed you must learn to think logically, while not destroying things.


=== trans/level_complete_stats ===

$65428404547905* Stats


=== trans/level_maze_description ===

$25068965294593* [center]Get to the door of the maze[/center]


=== components/Or64 ===

$50631450923181* Bitwise OR two values
$62930122175674* 64 Bit OR


=== trans/manual_text_bytes ===

$73333514253412*
This game asks you to build an 8 bit computer.  Practically this would normally require the player to put down 8 parallel wire lines in many places.
To alleviate tedious busywork, you are given the notion of a byte, which is just a virtual bundle of 8 bits.

The state of either a byte input / output or wire line is represented by a number, instead of the red or green color.


=== trans/manual_robot_controls ===

$94513149242653* Robot controls


=== misc/watchable_state ===

$58678516111149* Link components


=== components/Xnor64 ===

$64937916903935* Bitwise XNOR two values
$47129074382309* 64 Bit XNOR


=== levels/wide_instrucitons ===

$13709034294291* Save on even tick, output both bytes on odd ticks
$17693995237077* Output both bytes
$19068760748550* Output 0 on even ticks
$65009239162932* The correct outputs were {a} and {b}
$19203973423116* Create a device that saves the program output on even ticks, and outputs both bytes on odd ticks.
$17409169138995* Save the byte


=== components/Nor32 ===

$82743668258816* Bitwise NOR two values
$82121937858245* 32 Bit NOR


=== levels/bit_switch ===

$56295261249455*
If components output different values on the same wire, you get an error. However, some components have grey output pins, these are not outputting at all when the component is not enabled. This is the case for the Bit Switch component.

[img]dialogue/bit_switch.png[/img]

This means that more than 1 of these grey output pins can connect to the same wire and not cause an error, as long as only one of them is enabled at a time.
$42793594302151* Using 2 NOT gates and 2 Switches, build an XOR gate.


=== main_scripts/input ===

$10186190492148* ALT click to move wire head


=== components/Not64 ===

$74829633052959* Bitwise negates 64 bits
$81823773658328* 64 Bit NOT


=== components/Stack ===

$71022099146246* Memory that can be pushed or popped onto
$47202418972371* Stack


=== ui/schematic_ui/confirm_delete ===

$46014905606975* Yes


=== trans/levels_saving_bytes_text ===

$36838510526259*
[right]Action
Desired state
Desired output
[/right]


=== misc/sandbox_toggle ===

$30516879701896* Sandbox


=== trans/manual_side_the_robot ===

$56547245144983*
[color=#e49f44][b][/b][/color] The robot sees one 
  tile ahead. The name
  and ID are shown up 
  here. This ID number
  is also the computer's 
  input.


=== trans/level_decoder_1_RichTextLabel2 ===

$50454539040073*
[right][color=#e49f44]Input[/color]
Output 1
Output 2[/right]


=== components/Rol64 ===

$49017662473189* Rotates the bits of an input left
$13677051385046* Rotate left


=== levels/byte_shift ===

$16023356915123*
The task in this level is to shift the first input to the left by the value given in the second input. The second input will never exceed 7.

$37338672894296* Shift the bits of {value} left by {amount}
$10598344098990* [center]Shift the first input left by the number of places given by the second[/center]
$16216408139965*
To [color=#e49f44]shift[/color] a value 1 left just means moving all the bits in a byte to the left by 1 position.
For example: [color=#e49f44]90 shl 1[/color]

[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] would become:
[ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] [OFF]

Shifting by 3: [color=#e49f44]90 shl 3[/color]
[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] would become:
[ON] [ON] [OFF] [ON] [OFF] [OFF] [OFF] [OFF]


$18137790657923* In addition to giving you a shift left component, we also had the intern create a shift right component. All he had to do was to create the mirror version of this schematic.
$18518173140953* I recommend that you add [color=#e49f44]shift left[/color] and [color=#e49f44]shift right[/color] to your hardware for future levels.


=== misc/restore_overture ===

$52008982212566* Reset


=== trans/credit_header ===

$21717110565858* Credits


=== main_menu/sandbox_button ===

$16857608955464* sandbox


=== trans/_second_tick_RichTextLabel2 ===

$11680718497014*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== trans/level_complete_level_map ===

$20801641140962*
[b]Level map mode[/b]
[color=#cccccc][i]Click "[color=#e49f44]Onwards[/color]" and you will see[/i][/color]


=== levels/xnor ===

$11090938799865* Create the inverse XOR gate, known as XNOR.


=== levels/bit_inverter ===

$15769391111364* When "Invert" is [ON], output the opposite of "Value". Otherwise, just output "Value" as is.
$15272914096446* This level is exactly the same as the XOR one you solved before. Remember no matter what we tell you the goal of the level is, the real truth is in the truth table.
$14944872827527* Despite the funny background you figured out this was just the XOR gate in disguise! Well done.
$16125025706490* Hmm, perhaps you have studied memory a little bit too well...
$13224963076378* We are experimenting with how backgrounds influence cognitive functions in earthlings.


=== levels/ram_block ===

$12901484249817* Can you fit 4 bytes of memory in this limited space?
$14218335256117*
In our advanced civilization, forcing prisoners to do extremely menial tasks is slavery and is technically illegal.
	  That is why we instead had our intern create the 256 byte version of your component.
$15908016538045* VALUE
$16196915566111* 0
$14259545926196* A
$12306130287676*
In this level you have to build a circuit that 
can [SAVE] or [LOAD] from 4 different bytes of memory.

You are given 1 bit that determines if you are to [LOAD]. Another bit determines if you are to [SAVE] and it comes with a corresponding value.
Additionally, you have 2 address bits. 

With 2 bits, there are 4 combinations, one for each byte of memory in this level.
[i][tip]Join wires in the middle and use right angles or this will be a mess.[/tip][/i]
[i][tip]Spacebar rotates components.[/tip][/i]

The output has an enable pin, enable it only on [LOAD].
$18084166025569* Nothing
$13082830776248* DON'T LOAD
$12933801309767* A


=== trans/options_confirm_reset ===

$55371048386984* Right


=== components/Shr64 ===

$93124177265670* Shifts the bits of an input right
$73798355428095* Shift right


=== components/Constant64 ===

$92424468899005* Constant value
$25858905835416* 64 Bit Constant


=== component_panels/LatencyRam ===

$87788654491792*
This kind of RAM would add 1024 delay to the circuit, but instead of extending the duration of ticks, we simply don't wait for the output.

Practically this means that [color=#e49f44]reading takes {ticks} ticks[/color] (since your circuit has {delay} delay).


=== misc/ui_panel/left_inputs ===

$16586225094516* INPUTS


=== trans/manual_console ===

$73523750891893* Console


=== components/OutputCounter ===

$52247325526438* Counter


=== trans/always_on_RichTextLabel2 ===

$86547293707045*
[right][color=#ffa502]Input[/color]
Desired output
Current output[/right]


=== components/Xnor16 ===

$73699169812942* Bitwise XNOR two values
$40088995721509* 16 Bit XNOR


=== components/Off ===

$61860786587357* OFF
$72749460799924* Always [OFF]


=== components/Shr16 ===

$20291717268875* Shifts the bits of an input right
$31674686871821* Shift right


=== components/Screen ===

$12771040946773* Displays the visuals that accompany certain levels
$50037736094411* Screen


=== misc/ide_control_link ===

$80788685813993* Robot controls


=== levels/Calibrating Laser Cannons ===

$11331851878040* Also you now have access to assembly programming. It allows you to add names for instructions, so you can for example type "add" instead of inputting 68.
$11023157447564*
2×π×r

r is the input.
And you can approximate π as 3.

Send the answer to output when it has been calculated.
$15260627694444* In order to calibrate said laser, we want you to calculate the circumference of the asteroids using an advanced equation.
$12669851602178* [center]Calculate the circumference of the asteroids[/center]
$21601709632806* What is 2π × {radius}?
$16954408093587* On our ship we naturally shoot incoming asteroids with lasers.


=== levels/circular_dependency ===

$16336401898647* Test 1/2
$13880985462901* Make a circuit where the input of a component depends on its own output
$18010308863615*
Create a "circular dependency". This is a circuit where the input of a component relies on its own output. In a circular dependency situation, it is not possible to determine the output of a component, because you would first need to determine the input, which relies on the output and so on (hence the "circular").

This state is normally not allowed in other levels, but in this level the goal is to create it, so you understand what it is before going forward.
$13520037133129* I am not sure it benefits the students, but teachers love it.
$11316928751185* In our education system we traditionally teach by tricking students into doing the wrong thing and then teasing them.


=== misc/options_Score Sync ===

$45371978167502* Score sync


=== trans/map_keys_to_pan ===

$26276191141664* Use keyboard to pan


=== components/Xnor32 ===

$17419057954798* Bitwise XNOR two values
$52489451755306* 32 Bit XNOR


=== trans/manual_send_otuput_robot ===

$65542429897149* [center]Send output to control the robot[/center]


=== components/Or3 ===

$17576327690867* 3 pin OR gate
$99630419947500* 3 Pin OR


=== ui/top_bar/scores ===

$56840961921536* GATE SCORE: \nDELAY SCORE:


=== trans/level_binary_search_description ===

$11976224688780* [center]Recover the passcode[/center]


=== components/Output1Sum ===

$90026011029075* Sum


=== components/Input64 ===

$31709565019284* Input


=== trans/level_component_factory_Label2 ===

$37347658035959* Component preview


=== trans/level_binary_programming_description ===

$66247694103179* [center]Add 5 to the input[/center]


=== components/Input 4 ===

$11447837612693* Input


=== trans/or_gate_3_RichTextLabel2 ===

$56903547636751*
[right][color=#e49f44]Input 1
Input 2
Input 3[/color]
Desired output
Current output[/right]


=== levels/Add 5 ===

$11540713506719*
You are now free to change the program of your computer.
Click the edit icon on the program component to start programming.
$19281970848639* [center]Add 5 to the input.[/center]
$17770257567603* So in the meantime we will have you help out on the ship a little.
$19446152707984* Click on the edit memory icon on the program component to start programming your computer. Your computer should read an input, add 5 to it and output it again (no need to worry about overflow).
$80639633676917* Input:
$12078933051174* But since you don't know how to program it yet, you are not quite ready for that.
$11074247151096* Notice that the immutable red register components have been replaced with a custom component with identical functionality.
$18134632592542* You have built your computer, but to win the competition you still have to finish the maze.


=== trans/not_gate_click_next2 ===

$20820887361993* Click "Next tick" to see


=== components/Output16z ===

$78873885833823* Switched Output
$54278394672948* Only outputs if the switch pin is [ON]


=== trans/manual_text_turing_complete ===

$54897112350567*
Certain computers, like simple calculators are limited in the algorithms they can perform.

They cannot perform any calculation that requires looping or recursing an arbitrary amount of times. Technically machines without looping or recursion can only deal with combinational logic.

Turing complete machines on the other hand are as powerful as it is possible to be. A Turing complete machine may have a slow CPU, but it is powerful in the sense that there is no (computable) algorithm it can't perform.


=== trans/manual_short_circuit ===

$41209541005460* Short circuit


=== components/ByteMul ===

$56549841656852* Multiply
$68631919890554* Multiplies two inputs


=== trans/map_assembly_challenges ===

$31733554125775* ASSEMBLY CHALLENGES


=== levels/1_decoder ===

$16057674753878* Create a component that can switch a signal between 2 pins.


=== levels/byte_mux ===

$49305362057225* Your answer {your_answer}\nCorrect answer {correct_answer} (Input {input})
$18296416014178* When the bit selector input is [OFF], output Byte A, otherwise output Byte B.
$17093993196554*
Even though he did not pass our tests we decided to keep the dog. Unlike most earthlings he is fluffy and follows simple instructions well. 

We might want to team you two up, since you compliment each other's shortcomings well.


=== trans/architecture_2 ===

$38100016313511* CPU ARCHITECTURE 2


=== trans/level_byte_constant_description ===

$84789919073603* [center]Always output the number 164[/center]


=== misc/component_factory_toggle ===

$55499239951858* Component Factory


=== trans/map_basic_logic ===

$75078723880086* BASIC LOGIC


=== components/Counter32 ===

$87245349851451* 32 Bit Counter
$92765669828982* Increments each tick, unless overwritten


=== components/Output8z ===

$16915419621070* Switched Output
$58449766432492* Only outputs if the switch pin is [ON]


=== components/And3 ===

$19664974941910* 3 Pin AND
$86839706221116* 3 pin AND gate


=== components/Add32 ===

$91616185859914* Adds two inputs
$64111401384153* Add


=== components/NEG ===

$88379907297327* Negate
$62021716182809* Bitwise negates an input


=== components/Or32 ===

$92752025948920* Bitwise OR two values
$40180779432911* 32 Bit OR


=== trans/options_robot_up ===

$92522280178363* Up


=== trans/options_disagree ===

$60077370372179* Disagree


=== trans/instructions_hint ===

$65105856275770* [center][color=#c5c5c5]Click to toggle the bits[/color][/center]


=== trans/options_redo ===

$50610605761210* Redo


=== nim/backend ===

$98703677236827* 1 minute ago
$86244493049244* {hours} hours ago
$95018143828198* 1 year ago
$21685594109067* Just now
$98363990684104* 1 hour ago
$84076931764831* 1 day ago
$18300496139706* 1 month ago
$17901039729248* {months} months ago
$42553566189409* {minutes} minutes ago
$70945526841433* {years} years ago
$14036822471924* {days} days ago


=== misc/reset ===

$39440928972984* Reset (Hotkey: F4)


=== components/NOT ===

$34453052824732* NOT
$90844421681709*
Inverts the input
[table=3]
[cell]Input[/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]


=== levels/Crude Awakening ===

$12508086025944*
We are testing you.

The rules are simple, build a functional computer or you will be eaten. Good luck.
$16321577947087* Congratulations, you have been abducted!
$19257730429557*
A signal flows from the input to the output.
In the upper left corner under "input" there is a green icon, 
click on it to turn the input component off. 
$17675121574388* Notice that the output component is turned off.\nThis is because the signal stopped flowing from the input component.


=== misc/program_edit_button ===

$38481453712356* Edit memory


=== misc/wire_draw ===

$59836059268386* New wire (Hotkey: Alt & drag)


=== levels/byte_or ===

$10368115829346* But actually it is OK because you lived good lives in the wild and we don't let the meat go to waste.
$15923734370936*
OR each bit of the input bytes and output the result.

For example:
[code]
INPUT 1 [ON][ON][OFF][OFF][OFF][OFF][OFF][OFF]
INPUT 2 [OFF][OFF][OFF][OFF][ON][ON][OFF][OFF]
OUTPUT  [ON][ON][OFF][OFF][ON][ON][OFF][OFF][/code]

$15226896485081* You may think it is unethical to eat all the earthlings that don’t win the competition?


=== trans/level_registers_code ===

$40063003736243* [center]OR[/center]


=== components/DivMod32 ===

$61314390474120* Divide and mod 2 numbers
$84309999871615* Divide


=== trans/instrucitons_header ===

$14831276667273* [center]Instructions[/center]


=== trans/level_the_bus_description ===

$20464862486158* [center]Copy the value from the correct input, to the correct output[/center]


=== trans/level_complete_hex ===

$94261690850981*
[b]Hexadecimal[/b]
[color=#cccccc][i]Toggle between signed, unsigned and hex numbers[/i][/color]


=== components/And16 ===

$56198785587874* Bitwise AND two values
$26727645933234* 16 bit AND


=== misc/inst_new_rule ===

$41064305626707* New rule


=== levels/always_on ===

$17712385236630* Create a circuit that is always [ON].


=== components/And64 ===

$80790829001391* 64 bit AND
$89424947351456* Bitwise AND two values


=== misc/instr_clone ===

$69090690657232* Clone


=== misc/option_reset ===

$15557473522933* Reset


=== trans/level_complete_gate ===

$99373213759665*
[b]Gate score[/b]
[color=#cccccc][i]You can now view the gate score of  wires and components.[/i][/color]


=== components/ByteEqual ===

$39369982838671* Equal
$35668435514829* Checks if the two inputs are equal


=== levels/binary_racer ===

$16076448195257* This level is my favorite pastime. Converting decimal into binary under time pressure.
$29718660090112* Wrong answer
$37319690622142* Good job, you reached level {current_level}.
$19111664765554*
Toggle the bits in the level panel so they add up to the decimal number in the question.

You must beat level 3 to pass.

(click [color=#e63e5b][url=accessibility_mode]here[/url][/color] to turn on timerless accessibility mode)
$11176073682097* What is {number} in binary?
$71866932309393* You made it to level {level}!
$37093663674348* Level {x}


=== components/Mul64 ===

$72281597169494* Multiply
$11665562499390* Multiplies two inputs


=== levels/xor_gate ===

$14093358515620* This is also known as an XOR gate. This level is difficult, so don't be discouraged if you don't get the answer right away.
$19182751521677* Last level you built a circuit that was [ON] when we were at the second tick. This level build a circuit that is [ON] when we are at the second OR third tick.


=== components/Bidirectional64 ===

$82412839066570* 64 bit bidirectional pin
$24932613021646* Can circumvent certain circular dependency errors


=== trans/level_complete_profile ===

$78783902500954*
[b]Online profile[/b]
[color=#cccccc][i]Find it in the main menu.[/i][/color]


=== levels/bit_adder ===

$13109388951000* We measure the universe with numbers. So your machine must learn to count.
$16564356062672*
Treat the inputs as [ZERO] or [ONE] depending if they are [OFF] or [ON]. Add them together in binary, such that the result is either [ZERO] or [ONE].

As with normal addition, if the result cannot be described with one digit, set the carry to [ONE].


=== trans/options_robot_left ===

$73654791275689* Left


=== trans/options_robot_right ===

$70185788176428* Right


=== components/Maker32 ===

$82420653444614* Turns 32 bits into 4 bytes
$85308499118176* 32 bit Maker


=== trans/options_inline_latches ===

$53886441687616* Allow circular recipes


=== misc/add_code_name ===

$57358078712675* Save


=== levels/double_number ===

$74261206899285* Your result {input} × 2 = {your_answer}\nCorrect result {input} × 2 = {correct_answer}
$19766257822639*
The input and output of this level are using bytes instead of bits. One of the two new components you are given takes a byte and splits it into bits and the other does the opposite.

Using those components, figure out how to double the input number (up to 127).


=== components/Hdd ===

$75645507178296* HDD
$78558655732992* Persistent memory


=== components/LessI32 ===

$87609006355839* Less (signed)
$99994775592318* Checks if one input is less than the other


=== ui/state_ui/title_screen/exit ===

$12639868461113* exit


=== trans/map_available ===

$81707212583931* Available


=== trans/manual_text_negative_numbers ===

$85226853816564*
The way to represent negative numbers you discovered is called "two's complement". It is the standard way to represent negative numbers in modern computers. The main advantage of two's complement is that the negative representation works seamlessly with the same adder that we used for the non signed representation.

In the early days of computing, the main contender to two's complement was one's complement. Its main advantage is that changing the sign of a number is simple, you just NOT each bit in the number. However, it has 2 representations for 0, a positive and a negative, which makes comparisons more difficult.

Another interesting representation, perhaps worth looking up is base -2, where the sign of the value of each digit alternates between positive and negative.


=== trans/options_console ===

$96601731563408* Open console


=== trans/options_window_mode ===

$54328660964287* Window mode


=== trans/options_waiting ===

$58990937331663* Waiting


=== misc/ui_panel/memory ===

$65362728703588* MEMORY


=== trans/ide_add_assembly_header ===

$94462268558066* [center]Add assembly code[/center]


=== trans/options_save_location ===

$61172959716558* Save location


=== misc/level_gate_component_icon ===

$83440578602427* Unlocks component


=== levels/any_doubles ===

$16587030847545* Because we are so technologically advanced we have machines fold our socks. Unfortunately the circuit that detects sock pairs broke on the machine.
$14373083988184*
This level has 4 inputs. 
Output [ON] when 2 or more of them are [ON].

[tip]Don't overthink this level.[/tip]


=== components/Output 1 + 1B ===

$43917122084061* Accepts output for levels
$81929942356043* Level output


=== components/Neg64 ===

$88458190974122* Negate
$52206550732945* Bitwise negates an input


=== components/DelayLine1 ===

$30487770736917* Delay Line
$38206009264853* Outputs this tick's input, next tick


=== ui/options/Robot Controls ===

$58799802152286* Robot Controls


=== misc/solution_option ===

$21618236951146* View solution


=== misc/confirm_factory_reset ===

$65699778604521* Delete everything


=== trans/map_programming ===

$44937904689376* PROGRAMMING


=== components/DelayLine32 ===

$56616725618490* Outputs this tick's input, next tick
$49292282287971* 32 Bit Delay Line


=== components/DelayLine16 ===

$61925612221077* 16 Bit Delay Line
$65706144678496* Outputs this tick's input, next tick


=== components/Nand64 ===

$27197172037913* 64 Bit NAND
$66590147372797* Bitwise NAND two values


=== misc/run_fast ===

$49363678936533* Run ticks faster (right click: change target speed)


=== levels/divide ===

$16412715945615* [center]Divide the two numbers[/center]
$14525870461271*
Integer divide two numbers to find the quotient and the remainder. Consider the fraction 7/3. 3 goes into 7 2 times and 1 is left over. Here 2 is called the [color=#e49f44]quotient[/color] and 1 is called the [color=#e49f44]remainder[/color].
In this exercise, you are first given the numerator (7 in the example) and then the denominator (3) and you are then expected to output the quotient (2) and then the remainder (1).
$76454016047920* {numerator}/{denominator} = {quotient}, remainder {remainder}


=== components/Nor64 ===

$17208777467974* Bitwise NOR two values
$72509242083648* 64 Bit NOR


=== trans/manual_RGB_color ===

$62337044104456* RGB color


=== components/Output 4 ===

$90190739202646* Output


=== components/Rom ===

$24976506406652* ROM
$81743370431597* Read only memory (outside the sandbox)


=== misc/instruction_expand ===

$44690074039467* Toggle define rules


=== levels/Delicious Order ===

$10160261151833* First read the 15 deliciousness scores from the input one by one. Your task is to output them in sorted order, smallest to largest.
$16027225087666* We are updating the galactic encyclopedia of food, inserting human foods. As we don't have an alphabet, entries in the encyclopedia are ordered by deliciousness.


=== trans/level_byte_adder_you_carry_text3 ===

$65048723622767* Number


=== trans/level_tick_tock_description ===

$34658332565777* [center]Add 1 to the counter, or overwrite it[/center]


=== components/IndexByte ===

$27264669944539* Byte Indexer
$54699455184164* Extracts a byte from a wire


=== components/Equal64 ===

$34603983706314* Checks if the two inputs are equal
$82876546747608* Equal


=== trans/manual_component_factory ===

$35460636622618* Component factory


=== components/Bidirectional16 ===

$31038378395810* 16 bit bidirectional pin
$99604485981015* Can circumvent certain circular dependency errors


=== trans/options_status ===

$35063135798145* Status


=== components/Register ===

$19705753304166* 8 bit memory
$68946767861738* 8 Bit Register


=== levels/Tower of Radioactive Alloy ===

$13757925963562* Specifically we want you to move piles of radioactive disks from an old reactor. Just be sure not to put a bigger disk on top of a smaller disk or the whole ship will blow up.
$10750976989948*
The first 4 inputs will give you the following in order:
disk_nr - The highest disk number in the pile (2 to 4)
source - Which location number to move from
destination - Where to move the pile to
spare - The 3rd spot that is neither the source nor the destination

Control the crane with the following outputs:
0 - Move the magnet to spot 0
1 - Move the magnet to spot 1
2 - Move the magnet to spot 2
5 - Toggle the magnet on or off

Play with the magnet manually by using the arrow keys to move and enter to toggle.
$19265994465686* We need you to help clean up the basement.
$35120623183961* Move from {source} to {destination}
$15855497886737*
Implement the following algorithm:

Tower of Hanoi algorithm:[code][color=#87a8c8]
func move(disk_nr, source, dest, spare):
	if disk_nr is 0:
		move disk from source to dest
	else:
		move(disk_nr - 1, source, spare, dest)
		move disk from source to dest
		move(disk_nr - 1, spare, dest, source)

move(disk_nr, source, dest, spare)[/color][/code]

[tip]Push register values to the stack to save them before calling a function that changes them.[/tip]


=== trans/manual_universal_gates ===

$28345532918560* Universal gates


=== trans/map_functions ===

$83960548773205* FUNCTIONS


=== components/Input 1 Byte ===

$40943344093513* Input


=== trans/wire_comment ===

$41481492318983* Wire comment
$87836369268219* Save
$34083666001769* Wire comment


=== levels/odd_number_of_signals ===

$16173829560311* Using a maximum of 3 components, output [ON] only when an odd number of inputs are [ON].
$85589489148198* Components spent\n{nr} of 3
$18288998816979* This level has a [color=#e63e5b][url=odd_number]hint[/url][/color] you can use if you get stuck.


=== trans/manual_text_binary ===

$69488982380310*
The numbers you are used to are base 10, here when we add a 0 to the right hand side of a number, it's value increases 10 fold.

Binary is base 2, so doing the same will instead just double it. In other words, each digit represents a power of 2. For example with [color=#c54d5e]base 2[/color] and [color=#e49f44]base 10[/color] color coded:
[color=#c54d5e]    1[/color] = [color=#e49f44]1[/color]
[color=#c54d5e]  10[/color] = [color=#e49f44]2[/color]
[color=#c54d5e]100[/color] = [color=#e49f44]4[/color]

To represent 6 we can simply add 4 and 2:
[color=#c54d5e]110[/color] = [color=#e49f44]6[/color]

Addition, multiplication and everything else works the same as base 10, except you carry when you reach 2 instead of 10.


=== misc/wire_color ===

$78287906849040* Wire color


=== trans/level_alu1_description ===

$90245779080897*
[center]OR, NAND, NOR or AND
the two bytes together[/center]


=== components/Program1Red ===

$26811947547688* Programmable memory component
$55594749714809* Program


=== levels/3_decoder ===

$19231618567710* With 3 bits of input there are 8 combinations. Make a circuit that selects 1 output for each of the 8 combinations. No more or less than 1 bit should be [ON] at a time.
$14293122338496* We had our intern add a "disable" bit to this component. We were tired of looking at him running in circles and were looking for other pointless and tedious tasks to give him.


=== levels/constants ===

$17098439090371*
We need a way to directly move numbers from our program into registers. For this we use the immediate mode (when the two highest bits are [OFF][OFF]).

When in immediate mode the whole byte is interpreted as a number that we [SAVE] into REG 0. This means we can 
[SAVE] any value between 0 and 63.


=== trans/ide_binary_header ===

$22615032668969* Binary Editor


=== trans/options_select_all ===

$21380256293472* Select all


=== trans/level_registers_text ===

$78241632854567*
[right][color=#e49f44]Code
Input[/color][/right]


=== components/BNOT ===

$53686485035156* 8 Bit NOT
$26822227902426* Bitwise negates 8 bits


=== levels/program ===

$16693098943939*
The [INSTRUCTION] input component has been removed. It has been replaced by a program component. Every tick, use the counter to load the next [INSTRUCTION] from the program's memory.
	
You must use the counter component you unlocked earlier for this level.
$19686277478479* The program is still outputting the first instruction. Did you hook up a counter?


=== components/Ror64 ===

$43920264894591* Rotate right
$49583010717958* Rotates the bits of an input right


=== trans/manual_components ===

$40288888375581* Components


=== levels/Arithmetic Engine ===

$16434409050195*
Add addition and subtraction to your circuit.

Instructions:
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND
4 ADD
5 SUB[/color][/code]


=== levels/capitalize ===

$14894954428144*
The inputs in this level represent the characters in a list of planet names, encoded as ASCII (see the manual). Each name is separated by a space which has the numeric value 32. Replace the first letter in each word with its uppercase counterpart.
(The possible input characters are a to z lowercase, space, apostrophe and dash)
$13301617098810* We had the intern type out planet names in human script. Unfortunately he forgot to capitalize each name.
$11647445869837* Input: 
$11201813578269* Output: 


=== levels/byte_equal ===

$17156565273196* Output [ON] when both inputs are the same.


=== trans/levels_counting_signals_RichTextLabel2 ===

$34604121212779*
[right]Input 1
Input 2
Input 3
Input 4[color=#e49f44]
Desired output
Current output[/color][/right]


=== trans/level_program_text ===

$38014836341470*
[right][color=#e49f44]Code
Input[/color][/right]


=== trans/manual_text_matrix ===

$75170402412137*
[b]Showing letters[/b]
It just so happens that a pixel space of 5x7 while small is still able to render letters nicely. By adding an extra row and column, these letters will also look nice when put next to each other. 

[center][img]dialogue/manual/matrix_letter.png[/img][/center]


[b]Small tileable screen[/b]
Rotating the component, you get 8x6 pixels, which has a nice 4:3 aspect ratio and tiling these, you can get most resolutions you might want. The way the pins are set up on this component was specifically designed to allow tiling. Imagine the naive pin design where each component is enabled by a single bit. This would require you to connect 1 wire for each component. In this situation, the number of wires needed for a tiled screen would scale with the area, while the gap needed to fit wires between components, would scale with the circumference. 

[center][img]dialogue/manual/tilable_screen.png[/img][/center]

Instead, by having 2 enable pins, one wire can enable a whole row and another a whole column. This way, a single component can be selected by its unique row and column combination. Further, fitting the rest of the data on the same wires, means that the horizontal and vertical gaps only need to be 1 square wide. This component visually takes up half a square extra on all sides, such that these components can be tiled up pixel perfectly, with 1 square hidden between them for running wires.


=== trans/map_memory ===

$58330421958143* MEMORY


=== trans/level_complete_stat_time ===

$39203727515285* Time


=== components/Rol8 ===

$79612280948390* Rotate left
$55557725551789* Rotates the bits of an input left


=== components/OR ===

$13013154620359*
[ON] when either input is [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell][cell][ON][/cell]
[/table]
$97247779246257* OR


=== ui/options/General ===

$36195388998735* General


=== trans/options_robot_shoot ===

$52956877721342* Shoot


=== trans/levels_double_the_number ===

$41609125516676* [center]Double the number[/center]


=== levels/not_gate ===

$19085882338208* [b]Instruction[/b]\nRight click to deselect
$10042327259531* Now that you unlocked the NAND gate, it is time for you to build a circuit.
$14042842216181* Last level you made the table that described the circuit. In this level you build the circuit that matches table.
$10604720087324* [b]Instruction[/b]\nBuild a circuit that makes the table correct.\nClick [i][/i] (Next tick) in the upper left corner to test each combination of inputs.\nYou win the level once both combinations have been tested correct.
$19798729463813*
Using NAND gates, build the NOT gate

Using: [b]NAND gate[/b]
[code]INPUT 1: [OFF][ON][OFF][ON]
INPUT 2: [OFF][OFF][ON][ON]
OUTPUT:  [ON][ON][ON][OFF][/code]

Build: [b]NOT gate[/b]
[code]INPUT 1: [ON][OFF]
OUTPUT:  [OFF][ON][/code]

$18442122157391* [b]Instruction[/b]\nDeselect the component by clicking the background
$12880883686501* [b]Instruction[/b]\nClick on the NAND component on the top right side of the screen and place it
$18780831606716* [b]Instruction[/b]\nClick and drag on the board to add a circuit


=== trans/level_delay_level_description ===

$24326379952614* Create a circuit that costs 5 GATEs and 6 DELAY


=== components/IndexBit ===

$89611629299917* Bit Indexer
$84431924133490* Extracts a single bit from a wire


=== trans/level_spacial_invasion_description ===

$44980627299841* [center]Shoot the space rats![/center]


=== levels/registers ===

$10661964231175* I have locked the red components of this level in place, since you always make a mess and don't leave enough space. The mess you make from now on is saved between levels, you no longer get to start fresh each level.
$10211777161405*
These are the bit patterns for each [color=#c54d5e]source[/color] and [color=#e49f44]destination[/color].

[color=#c54d5e]Source[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  INPUT 
[ON] [ON] [ON]  UNUSED

[color=#e49f44]Destination[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  OUTPUT
[ON] [ON] [ON]  UNUSED

To get a more intuitive understanding of the requirements, click the [INSTRUCTION] icon in the upper left corner.
$15888345020710*
In this level you need to create a circuit which can copy from a [color=#c54d5e]source[/color] to a [color=#e49f44]destination[/color]. 

The instruction byte in this level determines the [color=#c54d5e]source[/color] and the [color=#e49f44]destination[/color]. 

Bits 1, 2 and 3 give the [color=#e49f44]destination[/color]. Bits 4, 5 and 6 give the [color=#c54d5e]source[/color].
$14823499195861* Open "Instructions" in the top bar
$14108238519744* Time to create your master project, implementing the [color=#e49f44]OVERTURE[/color] computer architecture. This will be an actual Turing complete machine, a true computer in every way!
$14411286553593* Finally, the input and output components now have an additional pin. Set that pin [ON] when you want to read from input, or copy to output.
$14041158687959*
[color=#c54d5e]Source[/color] and [color=#e49f44]destination[/color] can be 1 of 6 registers, we will name them REG 0 to REG 5 respectively. 
	
Additionally, this map has a dedicated input component, which can be the [color=#c54d5e]source[/color] and an output component, which can be the [color=#e49f44]destination[/color].


=== components/Output 2 ===

$73255344581755* Output


=== components/Nor16 ===

$57921392198825* Bitwise NOR two values
$69522380057631* 16 Bit NOR


=== components/Input 1B CODE ===

$16878300327380* Instruction


=== components/Input32 ===

$10677927084411* Input


=== misc/level_gate_manual_icon ===

$22002156022920* Unlocks manual entry


=== components/LatencyRam ===

$74156976676497* Latency RAM
$31261866779127* Lowers delay by having save and load take several ticks to complete


=== components/DotMatrixDisplay ===

$18651725958642* 6x8 Dot Matrix Display
$71512568789377* 6x8 pixel display


=== components/Ror32 ===

$84788620524361* Rotate right
$50013003040535* Rotates the bits of an input right


=== components/BOR ===

$19406015796751* Bitwise OR two values
$54190050450484* 8 Bit OR


=== levels/Masking Time ===

$19351773688761* Ticks left: {ticks_left}  Input: {input}
$16810715868480* Calculate modulo 4 of the input.
$17375862136921*
The length of our week is 4 days. Our weekdays are named Zero's day, One's day, Two's day and Three's day. I hear some earthlings number their Two's day incorrectly? 
	
It doesn't really surprise me.
$65431688078892*
In this level you are given a number as input and you should return that number modulo 4 as a result.

The challenge is that you only have {ticks_per_test} ticks to output the desired result.

Note, you don't need to change your hardware, you just have to figure out the trick to do modulo 4 quickly.
Use [color=#e63e5b][url=masking_time]this hint[/url][/color] if you get stuck.
$81055582534899* Anyway new year is coming up and we want you to calculate the weekday of everyone's birthday. We will give you the date and all you have to do is return the weekday within {ticks_per_test} ticks.


=== components/Console ===

$66743357915699* Console
$16105755937680* 80x24 text character display


=== trans/turing_complete ===

$35911376069529* Turing complete


=== components/LessI16 ===

$75600169624828* Less (signed)
$73697238171042* Checks if one input is less than the other


=== components/ByteLessI ===

$52765625016236* Checks if one input is less than the other
$25403981009644* Less (signed)


=== components/BitSwitch ===

$56917313833836* Toggles a bit
$41574334638147* Switch


=== misc/FileInput ===

$28866575833369* Reads bytes from your hard disk
$34159012148766* File Loader


=== trans/level_constants_description ===

$34641396464207* [center]Add constant loading to your architecture[/center]


=== trans/manual_circular_dependency ===

$40263928358112* Circular dependency


=== misc/overture_add_assembly ===

$10565133223872* Never
$62421757655527* Name a code and click save.
$63525237058165* Copy from {source} to {destination}
$24281479096246* When [color=#2b8738]result[/color] {condition}
$32873193471770* UNUSED
$88446594314360* Immediate: {number}
$94278717238239* Always
$79398554520691* {opcode} {reg_1} and {reg_2}
$72740868980397* {condition} copy {register} to counter


=== trans/or_gate_RichTextLabel2 ===

$56663370211115*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== levels/binary_count_down ===

$56999237564848* {x} seconds left


=== components/Output32 ===

$37476623180671* Output


=== trans/level_complete_level_complete ===

$49647690443210* [center]Level Complete[/center]


=== misc/profile ===

$32835651830157* profile


=== components/BeepBox ===

$15009144144117* Waveform Generator


=== trans/options_setting_export_assembled ===

$98549046707456* Export assembled binary


=== trans/options_setting_click_to_pan ===

$24654961601456* Click to pan


=== components/Mul32 ===

$98530670555665* Multiply
$51210946736766* Multiplies two inputs


=== components/Bidirectional1 ===

$95836352586032* Can circumvent certain circular dependency errors
$34912798641933* 1 bit bidirectional pin


=== components/Halt ===

$30351143139905* Halt

# This is the default message of the Halt component
$54106972240596* Halt
$62990744955549* Stops execution with a custom message


=== components/Bidirectional32 ===

$54631386552063* 32 bit bidirectional pin
$35105566244017* Can circumvent certain circular dependency errors


=== misc/program_edit ===

$57861256694537* Bytes {bytes_from} - {bytes_to}


=== trans/level_wide_instructions_description ===

$60538893544456* [center]Build a wide instruction program component[/center]


=== misc/specifications ===

$56390619785555* View instructions definitions
$68054407020318* Instructions


=== trans/manual_component_factory_text ===

$42847481618884*
Open the component factory by clicking on this button [img]dialogue/manual/component_factory_icon.png[/img] in the upper left bar.

The component factory allows you to create your own components. The logic you place determine the behavior of the custom component and the layout determines the shape. 

The input and output components you place become pins on the component. Like with other components, a component output leading back to its input causes a circular dependency. Outputs having a path back to inputs causes a circular dependency for custom components, even if the insides of the component would suggest there shouldn't be one. Not having to worry about the inside of components reduces the complexity of larger builds, however this strict abstraction can be inconvenient under certain circumstances. In that case, use the unbuffered pins. They allow bidirectional flow and use the insides of the component to check for circular dependencies.

Probes placed in custom components will show on their layout and can display values inside. Probes can be connected to other custom components, so that deeply nested values can be displayed. Values probed in this way can also be connected to the program component.

For the component factory, the file manager also manages the custom components. The file names decide the component name and the folder structure decides the components placement in the menu.


=== misc/delete ===

$53448014080434* Delete (Hotkey: Right click)


=== trans/level_complete_stat_delay ===

$43118901497406* Delay


=== levels/negative_numbers/test ===

$64427417171037* Test


=== trans/level_byte_adder_you_carry_text2 ===

$87943759248740* Carry


=== trans/manual_binary ===

$19098578855427* Binary


=== trans/options_comment_wire ===

$96449970906640* Comment wire


=== trans/manual_terminology ===

$13311390759928* Terminology


=== misc/controls2 ===

$38773676077206* Edit Instructions


=== components/NetworkClient ===

$44510554000571* Network
$90462653419289* Handles network connections


=== misc/factory_back ===

$98930461722118* Back


=== trans/options_animation_speed ===

$13442839894535* Wire animation speed


=== components/Xnor8 ===

$31985293401482* 8 Bit XNOR
$45789912406647* Bitwise XNOR two values


=== trans/level_bit_switch_RichTextLabel2 ===

$57920867194992*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== levels/or_gate ===

$12749704931323* You should be happy you get to participate in our glorious tests.
$11472059692644* You get a chance to communicate with very advanced people from the galactic civilization.


=== levels/full_adder ===

$17063157033479*
In the previous level we added together 2 inputs, this time we add 3. Once again, add the inputs together in binary, such that the result is either [ZERO] or [ONE].

As with normal addition, if the result cannot be described with one digit, set the carry to [ONE].


=== trans/levels_negative_descriptions ===

$87964635915702*
-127 to 127 representable:
0 to 127 same as before:
Works with adder:


=== components/3_decoder ===

$59129788113517* Toggles between eight outputs
$94375716460090* 3 Bit decoder


=== components/Counter16 ===

$37313834107391* Increments each tick, unless overwritten
$49104925799943* 16 Bit Counter


=== components/Equal32 ===

$32710942647020* Equal
$32433537137277* Checks if the two inputs are equal


=== components/Byte Expander ===

$60488114435022* Splits a byte into 8 bits
$21904470559153* Byte Splitter


=== ui/toggles/level_log ===

$38557550573896* Level log


=== misc/instruciton_rule_label ===

$70464083627337* Label


=== components/Splitter32 ===

$90978982016052* Splits 32 bits into 4 bytes
$24096666569346* 32 bit Splitter


=== misc/change_schematic ===

$79554853897000* Switch schematic


=== trans/level_alu1_code ===

$20619700446604* [center]OR[/center]


=== components/Program64 ===

$76480303942112* Programmable memory component


=== components/Shl32 ===

$38930281262898* Shift left
$88685329847417* Shifts the bits of an input left


=== trans/level_byte_mux_description ===

$20538476756633* [center]Output the correct input byte[/center]


=== trans/options_cluster_color ===

$77850745497963* Apply color to wire cluster


=== components/DivMod8 ===

$37666366877853* Divide and mod 2 numbers
$44959426271423* Divide


=== components/Shl64 ===

$56766765894165* Shifts the bits of an input left
$37014604954362* Shift left


=== trans/level_program_description ===

$44017405175202* [center]Replace the input code with the program component.[/center]


=== misc/menu ===

$56916384895438* Main menu


=== trans/level_odd_ticks_RichTextLabel3 ===

$89508766742523*
[right]Input
Desired output
Current output[/right]


=== levels/xor ===

$11589029892097* XOR the bits of the inputs {a} and {b}
$12758156517177* Using the instructions of your computer, read the input twice and XOR the two values together
$16047615798435* [center]Read the input twice and XOR the bits of the two inputs[/center]


=== trans/level_byte_or_text ===

$99465606386164*
[right]
[color=#e49f44]Input[/color]
Desired output
Current output
[/right]


=== trans/manual_simulator ===

$19932404521621* Simulator


=== components/Neg32 ===

$26991597084705* Negate
$35735598635057* Bitwise negates an input


=== trans/level_dependency_description ===

$81238724438578* Make a wire where the input of a component depends on its own output


=== components/InputConditions ===

$75386511637758* Input


=== levels/the_bus ===

$72472660427162* [center]Copy the value from input {input_nr} to output {output_nr}[/center]
$96958133516462* FROM
$91318587712792* TO
$85140574084420* [center]Copy the value from the correct input to the correct output[/center]


=== components/Ram ===

$95418291334002* 256 Byte Ram
$27094240214067* Memory component


=== components/Constant16 ===

$85825068431072* 16 Bit Constant
$61330657823382* Constant value


=== levels/and_gate_3 ===

$14788981567936* Create an AND gate with 3 inputs.


=== components/DivMod16 ===

$42657221816637* Divide and mod 2 numbers
$22319923069746* Divide


=== components/MemoryProbeBit ===

$13846578075327* Display a value on your custom component or in the program editor
$25103579211328* Memory Probe (bit)


=== trans/manual_keynote_the_robot ===

$90224489436893* [center]Use arrow keys to play around[/center]


=== trans/level_byte_mux_text ===

$44961981616677*
[center]Your answer 11 + 88 =  0
Current answer 11 + 88  = 99[/center]


=== components/DualPortRam ===

$13408945557666* RAM with an extra load pin
$30400404542678* Dual Load RAM


=== trans/options_pan_up ===

$80031998727851* Pan up


=== levels/maze ===

$13225915898937*
If you choose to go on to the rest of the levels I will teach you about ram, the stack and function calls and you will get to solve more interesting challenges like this one.
		
But first you would have to build a better computer. [color=#e49f44]OVERTURE[/color] was good as a first machine, but it is clumsy and programs get very messy. To solve the challenges I have for you without pulling all your hair out, you will need something more expressive, the [color=#e49f44]LEG[/color] architecture.
$17275059688693* Congratulations, you won the competition! An amazing achievement!
$13741358519166* The fabled maze. If you solve it you win the competition!
$36193081514106* NOTHING
$10837851446666* WALL
$10598752971970* COIN
$40917300157127* SEEING:
$11103446544344* On the other hand, you could also retire, be proud and enjoy your reward of not being eaten.
$19331074553774*
Write an algorithm that gets the robot from the start to the exit. 

This level is hard, you probably want to write down the pseudocode for your algorithm before you implement it.

Use [color=#e63e5b][url=maze]this hint[/url][/color] if you get stuck.

[tip]Remember you can't use immediate values larger than 63, a common mistake is to try to jump to a label further down than the 63rd byte.[/tip]
$54151353200088* DOOR


=== trans/level_byte_adder_question2 ===

$85899338356278*
[right]Correct answer

Your answer[/right]


=== trans/level_constants_text ===

$29779449172278*
[right][color=#e49f44]Code
Input[/color][/right]


=== components/Switch64 ===

$80980797636768* Toggles a value
$93223372486795* 64 Bit Switch


=== misc/delay_overlay ===

$85430022417382* Show delay


=== levels/push_pop2 ===

$10062117579269* Add the stack to your computer
$14685569269160*
In this level you are supposed to add the stack to your computer and write the program that solves the level.
When the input is 0, you should [color=#e49f44]pop[/color] a value off the stack and output it. When the input is not 0, you should [color=#e49f44]push[/color] it on the stack.
$18561605111721* PUSH {input} on stack
$59658696292688* POP {value} off stack


=== trans/levels_not_RichTextLabel3 ===

$48425594158515* Build: NOT gate


=== trans/level_complete_stat_tick ===

$47758922161853* Tick


=== trans/level_complete_signed_numbers ===

$41649402437253*
[b]Negative numbers[/b]
[color=#cccccc][i]Toggle between signed 
 and unsigned numbers[/i][/color]


=== trans/level_codes_description ===

$24678249110160* [center]Add calculation codes to your wire[/center]


=== components/Rol16 ===

$48583573494467* Rotate left
$73379230742631* Rotates the bits of an input left


=== trans/options_synced ===

$99411066573242* Synced


=== trans/text_truth_table_left ===

$58617980046951*
[right]Input 1
Input 2
Output[/right]


=== trans/optoins_factory_reset ===

$17721051281188* Factory reset


=== trans/level_signed_negator_labels3 ===

$66996894079719* Desired   Current


=== levels/buffer ===

$10260210687588* [center]Test 2: Left input is [img]dialogue/on.png[/img], right output should be [img]dialogue/on.png[/img].[/center]
$13309706297402* [center]Test 3: Right input is [img]dialogue/on.png[/img], left output should be [img]dialogue/off.png[/img].[/center]
$17005228759908* [center]Make sure [img]dialogue/on.png[/img] can only flow from left to right.[/center]
$18349621873762* [center]Test 1: Both inputs are [img]dialogue/off.png[/img], neither side should turn [img]dialogue/on.png[/img].[/center]
$15504762262759*
This level starts with 2 special components. They simultaneously act as input and output.

Make sure the signal flows only from left to right. There are 3 tests.

[b]Test 1[/b]: Both sides will be [OFF].

[b]Test 2[/b]: The left side input will turn [ON] and the right side should be [ON].

[b]Test 3[/b]: The right side output will turn [ON] and the left side should be [OFF].


=== trans/manual_text_hard_disk ===

$82372297690518*
Hard disks are made of a spinning disk and a mechanical arm that has to physically move to load or save data. Of course physical movement is extremely slow in the timescales of electronics. Operating systems will normally order loads and saves such that the arm has to travel as little as possible.

The hard disk component has a "seek" pin, which lets you change the address you are looking at by the given amount. The addresses "wrap around", such that seeking 1 less than 0 moves you to the highest address, and seeking 1 higher than that gets you back to 0.


=== components/Equal16 ===

$97954874255512* Checks if the two inputs are equal
$33633607925660* Equal


=== ui/state_ui/state_ui_output_bit ===

$40754755480566* Output


=== trans/manual_delay ===

$78806697204524* Delay


=== levels/ai_showdown ===

$14940806461794*
His only weakness is gambling. We have lured him into playing a card game against you and if you win, he has promised to calm down.
You must win, you are our only hope!
$17297225655678* NAK 02 is our AI engineer robot. He is brilliant, but sometimes he goes rogue and tries to instigate rebellion.
$18848103966031*
Game rules: There are 12 cards on the table and each player takes turn and must pick up between 1 and 3 cards. You start and the player who picks up the last card (the joker) loses.

Reading input will give you the current number of cards. Sending 1, 2 or 3 to output will pick up that number of cards. NAK 02 reacts immediately, so you may read the input immediately after your output to get the result of his action.
$11794110848012* This time he has taken over the control room and holds the captain hostage.


=== trans/level_complete_stat_sum ===

$99546064626994* Score


=== components/InputOutput ===

$26488480303865* In/Out


=== components/Mux16 ===

$75979055121665* 16 Bit Mux
$13997767115693* Toggles between two values


=== components/Program8_1 ===

$11057354704814* Programmable memory component
$12805545963716* Program


=== levels/crude_awakening/next_level ===

$24027424800887* Next level


=== trans/level_alu2_description ===

$37432913848309* [center]OR, NAND, NOR, AND, ADD or SUB the two bytes together[/center]


=== components/Nor8 ===

$34517798310461* Bitwise Nor two values
$39421972053612* 8 Bit NOR


=== trans/level_complete_stat_gate ===

$95192766583497* Gate


=== levels/signed_negator ===

$10866019808027* For this level you probably want to turn on signed numbers, so the highest bit shows as -128. Click "+255" located in the top panel.
$10400106910274*
Taking the input as signed (where the 8th bit is -128), make a component that takes a number and negates it.
For example 4 negated would become -4. -9 negated would become 9.


=== trans/level_circumference_subscript ===

$80632450818467* [center][color=#cccccc](Assuming π ≈ 3)[/color][/center]


=== trans/options_missing ===

$22687523145097* Missing


=== trans/manual_delay_text ===

$52013630755752*
In real hardware all components have delay. This is important since the delay in a circuit determines the maximum speed at which you can run it.

Following wires from input to output and adding the delay of components in the path will give you the delay that path. The delay of a circuit is the delay of the slowest path.

Besides inputs, paths can also start from components with no reliance on early phase inputs (like Counter and On) and they can end at late phase inputs (see page).

Further, custom components don't have a delay score for the costliest path of the whole component, but rather the delay cost is calculated per pin. This is so as to not penalize using custom components by making faster pins cost the same as the slower ones.


=== trans/level_xnor_RichTextLabel2 ===

$59451104901430*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== components/Input16 ===

$34560561101846* Input


=== trans/level_ram_component_value_description ===

$53113984441582*
[right]Test
Address
Action
Expected output[/right]


=== trans/level_byte_less_description ===

$37336202055283* [center]Determine if the first input is less than the second.[/center]


=== components/Register16 ===

$16015376037787* 16 Bit Register
$71792123436163* 16 bit memory


=== levels/test_lab ===

$11038144815919*
This level uses programs to test your circuits. When the programs are run, this level checks if the linked components behaves the way you expect.

The lab has 2 extra keywords.

The [color=#c54d5e]expect[/color] keyword is used to describe what a value a memory address should hold next tick.

The first number after [color=#c54d5e]expect[/color] is index of the linked component, the second number is the expected value. The linked component index is just the order the components are connected up in to the program component.

[img]dialogue/watched_state.png[/img]

For example:
[code][color=#c54d5e]expect[/color] [color=#eb9433]2[/color] [color=#eb9433]4[/color]
[color=#4a9658]copy[/color] [color=#eb9433]4[/color] [color=#4a9658]_[/color] [color=#4a9658]r2[/color][/code]

Here, the first line says that we expect the 2nd linked component to hold a value of 4 after the next tick.

All linked components are checked against expectations at every tick. All linked components are expected to be 0 at the start of the program, and expectations for memory components only change as you specifically change the expectations. The one exception are counters, these are naturally expected to increment each tick.

The second special keyword for the lab is [color=#c54d5e]set_input[/color]. With this you can control the input of the computer:
[color=#c54d5e]set_input[/color] [color=#eb9433]123[/color]

You can at any time also (re)import example tests by clicking below:
[url=import_overture][color=#e49f44]OVERTURE[/color][/url]

$32399229965611* Also, since you have now completed [color=#e49f44]LEG[/color], I have unlocked all the 16, 32 and 64 bit components that you have in the sandbox.
$15446846177093* Welcome to the lab. Like the component factory, this is not a normal level but a tool.
$16072814175447* Programming on buggy hardware is very frustrating. It is painful to suddenly be forced to reason about circuits, when you are in the middle of solving a programming problem. It is tempting to apply a quick fix, so you can get back to solving the original problem. But now this quick fix broke something else in a program that used to work and so on. Therefore, when developing hardware try to aim for 100% reliability before you start programming!


=== levels/Opcodes ===

$19693461238792* Set the counter increment to 4
$38976231780455* Linked component {nr} should point to a register or custom component with a register inside
$20916717363300* Linked component {nr} should point to the output
$18189600217529* Implement the OPCODE instructions
$13450117997204* Add a counter to the circuit
$77044880242883* Linked component {nr} should point to the counter
$13870568875751* Create a new schematic and add a program with 4 byte output
$10303603301757*
Implement the following opcodes:
[code][color=#87a8c8]0 ADD
1 SUB
2 AND
3 OR
4 NOT
5 XOR[/color][/code]

The opcode NOT ignores the second argument.
$17495651785164* Add 6 registers to the map


=== components/Mem Unit ===

$57670626909848* 1 bit of memory
$78616473760551* 1 Bit memory


=== nim/backend_lib/level_list ===

$58391129129347* Registers
$45936227746026* Counter
$12946639957230* NOT Gate
$16881141174140* Binary Racer
$37136208388559* SR Latch
$32191988336459* Saving Gracefully
$59136962133320* Logic Engine
$30920780473397* Circular Dependency
$83321010943153* Counting Signals
$58769021955965* 3 Bit Decoder
$78673715398197* Immediate Values
$49679174636208* Byte XOR
$40356575891647* Byte OR
$44393538021725* Calibrating Laser Cannons
$87426564872318* Divide
$61228036919534* Tower of Alloy
$24593959732668* Signed Negator
$19487493622742* Half Adder
$26705128002562* Conditions
$94163943335575* The Sandbox
$64662599400870* Bit Inverter
$27566801288091* Component Factory
$14193654974055* Signed Less
$14522992467987* OR Gate
$74096060570427* Wide Instructions
$30630492494839* Byte NOT
$11457737665157* Wire Spaghetti
$59485174474959* Delicious Order
$85514901357243* Adding Bytes
$98013649264532* Stack
$35790581910835* Second Tick
$94979277765051* Robot Racing
$13303326918621* NAND Gate
$16463062897451* Crude Awakening
$77495536880911* NOR Gate
$61466151084505* Spacial Invasion
$20858506932774* AND Gate
$28827008935802* The Lab
$92696642439976* AI Showdown
$74688348772072* The bus
$74512388889988* Arithmetic Engine
$50884376329157* Little Box
$70651296323768* XOR Gate
$62326481348276* The Maze
$31140969090253* Planet Names
$42873691377272* Add 5
$36114120875026* Storage cracker
$45773199639367* Odd Ticks
$17198602105978* Unsigned Less
$43018398941741* Always On
$68155633878444* Delay
$15420972347773* RAM
$33343343932901* Turing Complete
$95989050249094* Bigger AND Gate
$81417895515868* Bit Switch
$69830943995038* One Way
$63331549672739* Opcodes
$87626070552799* Full Adder
$13219675195117* ODD Number of Signals
$62167495140389* Shift
$28985439820134* The Product of Nibbles
$94896856420525* XNOR Gate
$25805639594354* Program
$57870391153000* Immediate Values
$56272944092958* Delayed Lines
$96825664933181* Unseen Fruit
$86717899742637* Saving Bytes
$53092952738479* Input Selector
$70993791338383* XOR
$77453667419150* Instruction Decoder
$17750429607702* 1 Bit Decoder
$79570913613529* Double the Number
$59939822079116* Negative Numbers
$96898830278153* Byte Constant
$49328023903824* Equality
$91267697977186* Hex Racer
$74292408260828* Calculations
$45480765206717* Conditionals
$71126291573555* Double Trouble
$33132016601448* PUSH and POP
$75225719777307* Water World
$64615090872051* Functions
$84208736840052* Masking Time
$91954159574064* Bigger OR Gate
$36221227239949* Dancing Machine


=== ui/state_ui/title_screen/play ===

$66967233942803* play campaign


=== ui/options/Controls ===

$53266310714298* Control


=== misc/run ===

$67345621265845* Run ticks (Hotkey: F6)


=== levels/byte_not ===

$14196498898485* Tool making and usage is key in the early evolutionary stages of developing intelligence.
$12982025748137* "NOT" each bit of the byte input.
$10294533225655* Our previous model of brain size being the main predictor of intelligence was naive.
$14958585065722* Therefore the number of arms on a creature is clearly the main predictor of intelligence. Did you know there are sea creatures from your planet with four times as many arms as you and they are doing better in tests?


=== misc/credit_box ===

$15872341864658*
Sincere thanks to:

[b]Translators[/b]
{translators}

[b]Early beta testers[/b]
{beta_testers}

[b]Font work[/b]
{font_work}

[b]Soundtrack[/b]
 Adolfo Aaron Figueroa Bianchi

[b]Open source software[/b]
{software}

[b]Assets[/b]
{assets}



=== trans/options_pan_right ===

$33884219481037* Pan right


=== trans/options_pan_left ===

$78515694621006* Pan left


=== trans/manual_ASCII_encoding ===

$30404865580119* ASCII encoding


=== components/Maker64 ===

$17464069717985* 64bit Maker
$79677187590355* Turns 64 bits into 8 bytes


=== trans/not_gate_RichTextLabel2 ===

$10340875578771*
[right][color=#e49f44]Input[/color]
Desired output
Current output[/right]


=== misc/lab_toggle ===

$16432178820878* Lab


=== levels/Calculations ===

$14458828731919*
Time to merge in the "Arithmetic Engine" circuit you made previously with the register circuit. The calculation circuit was saved in the component factory and can now be added as a component. If you forgot which pin does what, check the circuit in the component factory.

Use the decoder you built to figure out if we should copy between registers or do calculations. Here are the 4 different modes again:
[OFF][OFF] Immediate
[OFF][ON] Calculate
[ON][OFF] Copy
[ON][ON] Condition

For this level you only have to worry about the copy and calculate mode, check the [INSTRUCTIONS] by clicking on [img=20]dialogue/instruction_icon.png[/img] in the top panel for the details. When in calculate mode, take [color=#e49f44]REG 1[/color] and [color=#e49f44]REG 2[/color] as inputs, and save the result in [color=#e49f44]REG 3[/color].

[tip]Don't forget the 3 bit decoder component has a disable bit.[/tip]
$13013863429580* For this level an extra pin has been added to the registers. This pin always emits the value of the register, regardless if load is selected or not.


=== trans/instructions_header ===

$15089281203426* [center]Instructions[/center]


=== components/Program4 ===

$27522667367787* Program
$45650720555565* Programmable memory component


=== trans/options_controls ===

$18297012748869* Controls


=== levels/Counter ===

$17701404772563* Add 1
$17940006660359* Count
$17263901743088*
Build a counter that will increase by 1 each tick.

Additionally, there should be an option for overwriting the counter with a given value.

You are given 2 inputs, a bit and a byte.

The bit input should toggle between counting and overwriting with the value of the byte.
$68874699768861* Overwrite with {value}
$10555159894041*
Counting is so fundamental even insects do it. From counting, species can evolve to compare and do arithmetic. And before you know it, you have apes building computers.

Make a device that counts increments once per tick.


=== components/Constant32 ===

$39402227599142* Constant value
$30896164786171* 32 Bit Constant


=== trans/manual_text_ram ===

$10969790213397*
This simulator has several types of RAM different trade-offs, similar to real life RAM options.

[b]RAM[/b]
The RAM component can store a lot of data, but adds a very high delay to the circuit.

[b]Fast RAM[/b]
The fast RAM has a low delay, but a very high gate cost per byte.

[b]Latency RAM[/b]
The normal RAM has very high delay, however instead of waiting for this delay each tick, we can treat the RAM as if load and save takes multiple ticks. The number of ticks save and load will take depends on the length of each tick. Say for example that our circuit has a delay of 100 units, a load would take 10 ticks, since we have to wait about 1000 units of delay. 

A common approach for pipelined architectures is to use Latency RAM as for main memory, but use a small amount of Fast RAM for caching. Since memory access is often adjacent or close (for example when looping over an array), fetching adjacent values when loading from Latency RAM and caching them in Fast RAM can significantly speed up certain kinds of programs.

The simplest way to integrate the Latency RAM is simply to stall the whole architecture while waiting for a save or load. An easy optimization on this comes from realizing that you don't have to wait for saves, except if you want to load.

[b]Dual Load RAM[/b]
Sometimes it is beneficial to separate parts of the logic into a separate processing unit, that operates more or less independently. This could be for handling a display device or a network connection. In these cases, the independent unit will often need to continuously load and save to memory, while the outside logic only needs to occasionally load. Use Dual Laod RAM to avoid having to schedule who gets access to the RAM at what time.


=== components/Xor16 ===

$55408021160573* Bitwise XOR two values
$47846591761838* 16 bits XOR


=== trans/level_tick_tock_keys ===

$11700778730606*
[right][color=#e49f44]Action
Desired output
Current output[/color][/right]


=== components/And32 ===

$98890160152994* Bitwise AND two values
$30264879217145* 32 bit AND


=== trans/manual_text_ascii_encoding ===

$57727768059917* This simulator uses (extended) ASCII in a few places. Below are the characters with their corresponding number. The console supports different versions of extended ASCII.


=== components/AND ===

$22719674432950*
[ON] when both inputs are [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell]
[/table]
$58912167455465* AND


=== trans/map_locked ===

$95146987030704* Locked


=== trans/manual_text_short_circuit ===

$31105471890701*
In electronics, two components outputting different values on the same wire causes a short circuit.

[center][img=100]res://dialogue/short_circuit.png[/img][/center]

However, by disconnecting output pins from a wire, it is possible for multiple pins to share the same wire (called a bus). Importantly, at most 1 component output should remain connected each tick, otherwise you risk a short circuit.

[center][img]res://dialogue/switch.png[/img][/center]

In this simulator, pins that can be disconnected are grey.


=== trans/nand_values ===

$38006065064488*
[right][color=#e49f44]Input 1
Input 2[/color]
[b]Output[/b][/right]


=== trans/manual_assembly ===

$14434902453525* Assembly


=== levels/decoder ===

$16133643476631* The circuit you built in the "Registers" level can copy values between registers, while the "Arithmetic Engine" can do different operations on 2 inputs. But you need to be able to do both in the same circuit. To do this, build a "decoder", which will decide which mode our computer is in, based on the 2 bits we haven't used yet.
$18435544383511* CALCULATE pattern\n[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$18945946395447*
To distinguish between the [INSTRUCTIONS] of 4 different kinds, the two highest bits will be used to determine which MODE we are in as follows:
[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Immediate
[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Calculate
[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Copy
[ON] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Condition

Here [ANY] means any value.

Determine the MODE we are in from the input, then send [ON] to the correct output.
$15105859227432* COPY pattern\n[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12671132029272* Your circuit has been saved to the component factory.
$12068329066372* [b]ALERT: THIS IS AN OUTDATED VERSION OF THIS MAP, PLEASE CLICK THE SAVE ICON IN THE TOP LEFT AND CREATE AND LOAD A NEW SCHEMATIC[/b]
$11382827588408* CONDITION pattern\n[ON] [ON] [OFF] [OFF] [OFF] [ANY] [ANY] [ANY]
$12976424717611* IMMEDIATE pattern\n[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12532951884542* IMMEDIATE


=== trans/level_compute_xor_description ===

$61886892927185* [center]Pairwise AND together each bit[/center]


=== trans/manual_truth_tables ===

$75695254533352* Truth tables


=== trans/options_effects_volume ===

$24145565754506* Effects volume


=== trans/level_signed_negator_description ===

$87777776285772* [center]Invert the sign of the number[/center]


=== main_scripts/overture_level ===

$11338791453100* Dynamic
$27259865408750* Next tick the counter value will be {next}, it should be {expected}
$95030012922256* Input should only be enabled when reading from input
$12873109232054* Expected output {expected}, got {got}

# "cond" is for condition, this label has to be short as it has to fit on a component
$94982725578534* COND
$47188699762650* Output not enabled
$28026304798371* Output should only be enabled when outputting
$85260864781281* Input not enabled
$96569633331621* Load {value} into REG 0
$16914143080303* Copy
$59042824277105* Immediate
$82949244692745* Calculate
$83829200305236* Expected output {expected}, got {got}


=== levels/Further Delayed Lines ===

$17366913897135* Construct a circuit that outputs the same as the input, just delayed by 2 ticks.
$60989431641221*
This level introduces the Delay Line component. It takes its input and outputs it 1 tick later.

[img]dialogue/delay_buffer.png[/img]


=== levels/negative_numbers ===

$12574817679356*
We need a way to have negative values in bytes. The scheme we have been using so far can represent all numbers from 0 to 255 using a byte. This scheme is called "unsigned", since it only deals with positive numbers.

We need a scheme that allows negative numbers, normally referred to as a "signed" representation. 

Additionally, it would greatly simplify future circuits if the representation works with the adder you already made. 
$17231048881956* To know the difference between things, you need subtraction. To get subtraction, first you need negative numbers.
$70755151984986* {a} should be {b}
$11067230116844* {number} is not representable
$62744038163781* OK
$19118970740682*
[color=#dd6576]Edit the numbers[/color] for each bit so that the following is true:

[color=#e49f44]1[/color]: All numbers from -127 to 127 should also be representable
[color=#e49f44]2[/color]: Bytes representing anything from 0 to 127 should be the same as unsigned
[color=#e49f44]3[/color]: The new number system should work with the adder (for results between -127 and 127).
$15431436023571* You have two ways to represent 0\nWhich leads to 0 + 1 = 0
$28284583096369* 1 plus -1 does not equal 0\n  
$57604042654667* {number} is not representable


=== levels/robot_race ===

$15403032472607* Robot racing is the favorite sport on the spaceship. Differently programmed robots complete an obstacle course. Among the robots that complete the course, the winner is the one who had the smallest program.
$19966247197959* This time you are controlling Fastbot, he doesn't see what is in front of him, but he can turn to a new direction and move in the same tick. Also he wears fancy red running shoes.


=== levels/NAND Gate ===

$17420270098223* In this level the challenge is to figure out how the NAND component works. Be [color=#dd6576]sure[/color] to figure it out before you complete this level, or you will get stuck next level!
$11034378482152* Correct! You have unlocked the NAND gate. With this component you can build everything else in your computer!
$18270083417453* Check
$19208664264770* [b]Instruction[/b]\nClick any of the gray buttons in the last row of the table.
$17923274216766* We have decided you are probably not a plant.
$14777350869870* We are very impressed with how well you completed the last test!
$17994568832660* [b]Instruction[/b]\nThe NAND component in the middle changes the flow of the circuit.\nUse the bar on the left to experiment with the inputs, see how they affect the output and fill in the last row of the table.


=== trans/nand_Label2 ===

$60885816586685* Output


=== trans/options_copy ===

$55679445263875* Copy


=== components/Input 2 ===

$86870364449392* Input


=== trans/tooltip_tooltip ===

$48829429502039*
[b]Run fast[/b]
[color=#cccccc][i]Run your computer without updating the UI at each tick[/i][/color]


=== trans/options_pan_down ===

$93140495547084* Pan down


=== components/DelayLine8 ===

$24840584785792* Outputs this tick's input, next tick
$63449911993783* 8 Bit Delay Line


=== components/Bidirectional8 ===

$20234315861487* 8 bit bidirectional pin
$49499540884410* Can circumvent certain circular dependency errors


=== components/Bit Compressor ===

$74338505460996* Turns 8 bits into 1 byte
$98747779812970* 8 bit Maker


=== components/Mux64 ===

$14050204031082* Toggles between two values
$66892629981737* 64 Bit Mux


=== trans/manual_hard_disk ===

$45865138134248* Hard disk


=== trans/options_reset_warning ===

$19141523477461*
This will delete all level solutions, custom components and architectures. This can not be undone, are you sure you want to do it?
(This will close the game, it will be reset once you start it again.)


=== components/NOR ===

$27510848535619*
[ON] when neither inputs are [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][OFF][/cell][cell][OFF][/cell][cell][OFF][/cell]
[/table]
$83375115196253* NOR


=== levels/hex_racer ===

$33474352861351* Level {x}
$92057009138253* What is {number} in binary?
$16009852370452*
When dealing with a lot of bits, binary can become hard to read. Hexadecimal (base 16) represents each combination of 4 bits as its own character:
[code]
0 [OFF][OFF][OFF][OFF]
1 [OFF][OFF][OFF][ON]
2 [OFF][OFF][ON][OFF]
3 [OFF][OFF][ON][ON]
4 [OFF][ON][OFF][OFF]
5 [OFF][ON][OFF][ON]
6 [OFF][ON][ON][OFF]
7 [OFF][ON][ON][ON]
8 [ON][OFF][OFF][OFF]
9 [ON][OFF][OFF][ON]
A [ON][OFF][ON][OFF]
B [ON][OFF][ON][ON]
C [ON][ON][OFF][OFF]
D [ON][ON][OFF][ON]
E [ON][ON][ON][OFF]
F [ON][ON][ON][ON]
[/code]

As an example where hexadecimal is much clearer, lets compare the representation of the largest 16 bit number:
[code]
Binary:      1111111111111111
Decimal:     65535
Hexadecimal: FFFF
[/code]

It is not easy to tell if the binary is missing a digit or if the decimal number is off by 1, the hexadecimal on the other hand is immediately clear (once you get used to the representation at least).
$40775762006843* Wrong answer
$84691609525475* This level is my second favorite pastime. Converting hexadecimal to binary under time pressure.
$45532697833519* You made it to level {level}!
$87016829502381* Good job, you reached level {current_level}.
$43463538043782*
Toggle the bits in the level panel so they add up to the hexadecimal number in the question.

You must beat level 3 to pass.

(click [color=#e63e5b][url=accessibility_mode]here[/url][/color] to turn on timerless accessibility mode)


=== trans/level_full_adder_RichTextLabel2 ===

$25766177620842*
[right][color=#e49f44]Input 1
Input 2
Input 3[/color]
Desired Sum
Desired Carry
Current Sum
Current Carry[/right]


=== components/Ror8 ===

$10802217509530* Rotates the bits of an input right
$70999134800536* Rotate right


=== levels/Water World ===

$13739681561355* Total volume: 
$19185457941725* Good news, we want to turn earth into an exotic water park!
$18940654086036* We need you to help us find a good location for the Pirate's Plunge waterslide. Specifically, we are looking for an area that can hold a high volume of water.
$14706805272652* Hit ENTER to show water
$12881972193444*
The landscape is 16 columns wide. Read the input 16 times to get the height of the landscape at each column from left to right.
	
Then output the total volume that the landscape can carry as the answer.


=== trans/map_arithmetic ===

$51337598329530* ARITHMETIC


=== trans/rotate ===

$88236351843942* Rotate


=== components/NAND ===

$71130919681688* NAND
$12903183841172*
[ON] unless both inputs are [ON]
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][ON][/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]


=== levels/delay_level_check ===

$59355217078543* Correct!
$68999077595244* Check
$90847326020954* Nope!


=== levels/Dancing Machine ===

$14975070588197*
We all like the way Robot moves on the dance floor. That's why we want him to lead our dance team. 
	
The only problem is to make him come up with original dance sequences. How do you make creativity out of deterministic logic you ask?

The answer pseudo random number generators.
$15955150920362*
In this level you only get one input, we call this the initial seed. The seed is put through the following steps to produce a pseudo random number.

In the algorithm below, "shl 1" means shift left once, "shl 2" means shift left twice and "shr 1" means shift right once.

[b]8 bit xorshift RNG:[/b][code][color=#87a8c8]
temp1     = seed  xor (seed  shr 1)
temp2     = temp1 xor (temp1 shl 1)
next_seed = temp2 xor (temp2 shr 2)
[/color][/code]
Next output next_seed mod 4, to move the robot. Finally use next_seed (before mod 4) as the seed to get the next number in the dance sequence and repeat.

(Notice the initial seed will never be 0)


=== trans/options_color_wire ===

$64341547590822* Apply color to wire


=== misc/program_edit_signals ===

$98772447663910* Link components


=== main_scripts/levels ===

$64510812504271*
Some of the components used are not supposed to be available in this level!
The solution is not scored.

# Level type for the level complete menu
$58769207148712* Component

# Level type for the level complete menu
$90134890578411* Misc

# Level type for the level complete menu
$69219742310717* Architecture


=== misc/credits ===

$15234594767991* credits


=== trans/level_decodre_RichTextLabel2 ===

$40723962298647*
[right][color=#e49f44]Input 1
Input 2
Input 3[/color]
Desired bit
Current bit[/right]


=== trans/manual_bytes ===

$46223559629673* Bytes


=== trans/options_music_volume ===

$93981778736076* Music volume


=== trans/manual_matrix_display ===

$86092436010494* Matrix display


=== component_panels/Counter ===

$57936010210151* Increment by: {amount}


=== trans/level_complete_ide ===

$56719825235196*
[b]CODE IDE[/b]
[color=#cccccc][i]Name codes and edit them in a convenient editor[/i][/color]


=== trans/level_alu2_code ===

$93157894815498* [center]OR[/center]


=== misc/binary_submit ===

$95509904060545* Submit


=== trans/and_gate_3_RichTextLabel2 ===

$52008707927408*
[right][color=#e49f44]Input 1
Input 2
Input 3[/color]
Desired output
Current output[/right]


=== components/ByteConstant ===

$29445030761909* Constant value
$25159790815891* 8 Bit Constant


=== components/Maker16 ===

$55864807379312* Turns 16 bits into 2 bytes
$39941195789458* 16 bit Maker


=== components/Output64 ===

$43552728118031* Output


=== trans/level_decoder_description ===

$10169248860836* [center]Decode the instruction[/center]


=== components/Switch16 ===

$15221175893882* 16 Bit Switch
$59845475842015* Toggles a value


=== trans/options_level ===

$64744152268407* Level


=== components/LessU32 ===

$72614358420262* Less (unsigned)
$55380524073095* Checks if one input is less than the other


=== levels/sandbox ===

$17054292175058* Welcome to the sandbox, here you are free to play around. I have given you 64 bit wires and a few IO components.
$10731996208080* There are also 64 bit versions of the program, the counter, the register and the ram. Notice though, the 64 bit ram takes 1 tick to load.
$72764802067974*
Welcome to the sandbox. 

Components are available in the menus on the right side. Once placed, click on the pins of the components and drag to connect them with wire. On the left you will find the UI for the simulation control. Note that you can right click on the "Run faster" button to set target speed.

You can find more information about the simulation in the manual (button is in the top left). Notable features to check out are the "component factory" where you can create your own components and the program component, which lets you define your own assembly.
$19454393978813* The keyboard lets you directly control your computer, using your ... keyboard
$14434122873489* The Waveform Generator lets you make sounds. I will probably regret giving you this one.
$18405942066048* The Clock gives you the current UNIX time in microseconds.
$10451578314373* The Console Screen lets you draw characters to a screen (see manual for ascii characters)


=== trans/level_complete_stat_type ===

$69511102367948* Type


=== components/Output64z ===

$61656790122480* Switched Output
$42506906257154* Only outputs if the switch pin is [ON]


=== ui/toggles/race_condition ===

$75558678297830* Circular dependency


=== trans/options_paste ===

$52159578521318* Paste


=== trans/level_double_buffer_RichTextLabel3 ===

$27208335953837*
[right]Input
Desired output
Current output[/right]


=== trans/manual_text_terminology ===

$99266452352883*
[b]Instruction[/b]
A byte or a few bytes that together make the computer perform a specific action.

[b]Opcode[/b]
The part of the instruction that determines which operation (like ADD or AND) is to be done.

[b]Memory address[/b]
A number used as a name for memory locations (often for registers). These are used to specify where an instruction is supposed to load data from or save data to.

[b]Jump[/b]
Changing the value of the program counter, changing which instruction is loaded next.


=== trans/manual_text_truth ===

$16559670174521*
The tables of input and output which are used everywhere throughout the game are commonly known as truth tables.








"Input" and "Output" will often be represented with variable names, like in algebra. And instead of using colors, you will often see the values represented as 0 / 1 or False / True.


=== levels/Conditionals ===

$10794262854382*
Add if statements to your circuit. For the if statements, the 2 arguments are compared and if the condition is true, the counter is set to a jump address.
	
The previous instructions had the 4 bytes represent:
[code][color=#87a8c8]OPCODE, ARGUMENT_1, ARGUMENT_2, RESULT[/color][/code]

For if statements the bytes represent:
[code][color=#87a8c8]OPCODE, ARGUMENT_1, ARGUMENT_2, JUMP_ADDRESS[/color][/code]

In addition to the previous opcodes, add:
[code][color=#87a8c8]32 IF_EQUAL
33 IF_NOT_EQUAL
34 IF_LESS
35 IF_LESS_OR_EQUAL
36 IF_GREATER
37 IF_GREATER_OR_EQUAL[/color][/code]

Use unsigned less / greater for the comparisons.

Each opcode does what their name implies. For example the following jumps to byte 16 if REG0 is less than REG1: 
[code][color=#87a8c8]IF_LESS REG0 REG1 16[/color][/code]

$18542005958715* Set the counter increment to 4
$17133561664335* Congratulations, you finished the [color=#e49f44]LEG[/color] computer!
$14973719570693* Add a counter to the circuit
$12920514303805* Add 6 registers to the map
$14309211963063* Create a new schematic and add a program with 4 byte output
$16826220977157*
 [color=#b72d41][b]TIP:[/b][/color] 
COPY is just ADD with the second argument being 0
$14690660047411* Implement the condition opcodes
$30132649789584* Linked component {number} should point to the output
$18994998239232* I will show you some upgrades you can make, on the path to implementing function calls. But from here on the details are up to you, I wont tell you what opcodes to use and so on.
$12034111753799* Linked component {number} should point to the counter
$36561706158040* Linked component {nr} should point to a register or custom component with a register inside


=== levels/byte_less ===

$11252365204151* Create a circuit that outputs [ON] when the first input is less than the second. Interpret the bytes as being [color=#dd6576]UNSIGNED[/color].
$62766453128684* Is {a} less than {b}?
$11632471752785* [center]Determine if the first input is less than the second.[/center]


=== levels/Logic Engine ===

$15865646260225*
 [color=#b72d41][b]WISDOM:[/b][/color]
Pain is temporary, glory is forever.
$17594613477534*
Create a device that can OR, NAND, NOR or AND two inputs. The third input will be the [INSTRUCTION]. An [INSTRUCTION] is just what we call the number that determines what to compute.

Instructions:
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND[/color][/code]

Also you can't move the red components in this level, for reasons that will be revealed later.


=== misc/multi_select ===

$85147529532131* Multi select (Hotkey: SHIFT & drag)


=== trans/level_byte_less_i_description ===

$21195810950441* [center]Determine if the first input is less than the second.[/center]


=== components/Splitter16 ===

$92674917729864* 16 bit Splitter
$28271182652741* Splits 16 bits into 2 bytes


=== trans/manual_text_universal_gates ===

$37735744928195*
It turns out that you can build all the logic for a computer out of either NAND or NOR gates. The Apollo guidance computers, were built entirely of NOR gates. Designed in the sixties, they had only 4KB of RAM and 32KB of disk space, but guided astronauts to the moon nonetheless.

Modern computers are not built entirely of just one of the universal gates, but when applicable NAND gates are preferred over NOR, because they have less delay and occupy less area.


=== components/Splitter64 ===

$80420054807186* Splits 64 bits into 8 bytes
$14205692632393* 64bit Splitter


=== misc/component_button ===

$75542474510177* GATE
$63839315669055* DELAY


=== components/SRLatch ===

$11641785582600* Set/Reset Latch
$71931050184389* [img=165]dialogue/sr_latch_tooltip.png[/img]


=== trans/levels_byte_or_description ===

$68379799788575* [center]Pairwise OR together each bit[/center]


=== components/Output 3 ===

$96269858195218* Output


=== components/Output 1B ===

$77044600156969* Output


=== components/Xor64 ===

$95012060885697* 64 bit XOR
$13031452187028* Bitwise XOR two values


=== misc/skipped_custom ===

$38174137226538* Select component

# This is the text on a button that appears when a custom component has changed size and no longer fits in a schematic. You can press this button to make the camera go to the location where the custom component was
$99860977387728* Go to location


=== components/ByteXor ===

$98219910712564* 8 bit XOR
$83236921580268* Bitwise XOR two values


=== levels/counting_signals ===

$10724914203078*
The output component of this level is a binary counter where the first 3 pins correspond to 1, 2 and 4.
Use the binary counter to count the number of signals.

Check [color=#e63e5b][url=counting_signals]this hint[/url][/color] if you get stuck

[i][tip]The solution for this level is not very neat and requires more components.[/tip][/i]

$10881918807029*
[color=#b72d41][b]TIP:[/b][/color] 
There is no shame in using pen and paper


=== levels/Spacial Invasion ===

$19967210826470* Be aware that the laser can only shoot when there are no other laser beams already in flight.
$16294185981398* The cargo hull has become infested with space rats.
$11505369795084* Check [color=#e49f44][url=the_robot]robot page[/url][/color] for instructions on how to program him. There is a link to that page in the program editor as well.
$10515630949378* We have hooked your machine up to our advanced robot and we want you to program it to shoot the space rats with lasers.


=== components/Nand8 ===

$50859914201083* Bitwise NAND two values
$93314093190526* 8 Bit NAND


=== misc/button_next ===

$50213503063080* Next tick (Hotkey: F5)


=== components/Add64 ===

$14174811828377* Adds two inputs
$73418471595285* Add


=== ui/toggles/level_map ===

$71951682957395* Level map


=== components/DivMod64 ===

$80284847781948* Divide
$71663353206665* Divide and mod 2 numbers


=== levels/saving_bytes ===

$10633476398156*
Create a circuit that can [SAVE] or [LOAD] a byte.

When the first input bit is [ON], [LOAD] the memory and send it to output.
When the second input bit is [ON], [SAVE] the input byte.

The output has an enable pin, enable it only on [LOAD].

$13502950630653*
[color=#ff9800]None
0
0[/color]
$19109563882664* DON'T LOAD
$16372198430230* SAVE
$15498440508450* Do nothing
$18873598212433* LOAD
$15582618410991* LOAD and SAVE


=== levels/byte_constant ===

$12641789008694* Create a circuit that always outputs the number 164.


=== main_scripts/leg_level ===

$70383685548547* REG {nr}
$53021804895845* ANDi
$69956969985790* ORi
$85913831661289* IF_LESS
$11144256835662* XORi
$61412773713567* SUB
$20104629254326* ARGUMENT 2
$65642901654732* {component} should be disabled
$52344899983501* IF_LESS_OR_EQUAL
$89945092889418* SUBi
$89011349770597* NOT
$71559031724238* IF_NOT_EQUAL
$98778676892898* {component} should be enabled with value {value
$40520283279584* XOR
$71204580217527* NOTi
$71195301111400* ADDi
$98178474649432* IF_GREATER_OR_EQUAL
$68187490877029* IF_EQUAL
$14186606871089* Next tick counter value will be {wrong_value}, but it should be {value}
$27868897434461* Could not find the counter component
$50722296752142* INPUT
$43723329256095* REG {nr}
$37810243909140* COUNTER
$44009845985661* ADD
$38681417496680* ARGUMENT 1
$68666991962246* OR
$24003300271049* {component} should have value {value}, not {wrong_value}
$79492115258673* IF_GREATER
$60997201855346* RESULT ADDRESS
$50231510806554* Could not find the program component
$64519909700148* AND
$49810487048038* COUNTER
$18236360532765* OUTPUT
$84307766381146* OPCODE


=== levels/call_ret ===

$15840165316981*
In this level you are tasked with implementing function calls and returns with the [color=#e49f44]call[/color] and [color=#e49f44]ret[/color] instructions.

Note that when returning from a function, you should jump to the address that came AFTER the [color=#e49f44]call[/color] instruction, otherwise you will end with an infinite loop.
The [color=#e49f44]call[/color] instruction has to do the following:
 [i]- Add the instruction width to the counter value and [color=#e49f44]push[/color] it on the stack[/i]
 [i]- Jump to the function address[/i]

The [color=#e49f44]ret[/color] instruction has to do the following:
 [i]- [color=#e49f44]Pop[/color] return address from the stack and jump to it[/i]

You can pass information to and from a function by saving the data to registers as normal. Also be aware of which registers a function will overwrite before calling it.

$19416009887091*
Sometimes it is useful to reuse a section of code. We call these sections "functions". To implement this reuse, one can [color=#e63e5b][url=terminology]jump[/url][/color] to the beginning of the function and jump back again at the end of the function. We call jumping to the function "calling" the function, and jumping back from the function "returning" from the function. 
	
But for this section of code to actually be reusable, the return jump will have to be able to return to different locations, depending on where we called the function from.

We could save the counter value to a register before jumping to the function and use this value when returning. However, if done this way, a function would not be able to call another function, since this would overwrite the original return address.

Say function A calls function B, who calls function C. When we want to return from C, we only need the return address for B and in B we only need the address for A. In general, regardless of which function we look at and how they are nested, the last return address we added is always the first one we will need again. This is exactly the behavior of the stack.
$19369640789869* Budget cuts have led to cutting salaries, but now the lab assistants are on strike. You will have to self-assess in this test. This will tell us something about your honesty and maturity.
$15463931654475* [center]Add "call" and "ret" instructions[/center]


=== levels/odd_ticks ===

$18510295620397* Output [OFF] on the even ticks and [ON] on the odd ticks.
$16987046679863* In a previous level you learned how we don't allow circular dependencies. Now you must learn the one exception.
$16037516781370*
Square pins in the game never affect the output in the same tick. They therefore never cause circular dependencies.
	
	[img]dialogue/delay_buffer.png[/img]
$17588119878416*
The delay line is allowed to depend on its own input. This is because its input does not influence the rest of the circuit until next tick.
	
[img]dialogue/delay_buffer.png[/img]


=== components/Adder Simple ===

$33973952772642* Add
$98429814030509* Adds two inputs


=== trans/manual_computer_concepts ===

$60892983318818* Computer concepts


=== misc/ProbeWireBit ===

$49521764791439* Wire Probe (bit)
$15206117280094* Display a value on your custom component or in the program editor


=== components/ByteShr ===

$89595863403484* Shift right
$69394421220436* Shifts the bits of an input right


=== trans/level_complete_delay ===

$73470840319057*
[b]Delay[/b]
[color=#cccccc][i]You can now view the delay of wires and components.[/i][/color]


=== trans/level_sr_latch_RichTextLabel3 ===

$55348415524361*
[right]Input 1
Input 2
Desired output
Current output[/right]


=== components/LessU64 ===

$13018528868948* Less (unsigned)
$90244529484227* Checks if one input is less than the other


=== trans/level_byte_no_description ===

$19806403089477* [center]Invert each bit[/center]


=== trans/level_saving_gracefully_RichTextLabel3 ===

$74117520663650*
[right][color=#e49f44]Save
Value[/color]
Desired output
Current output[/right]


=== misc/select_color ===

$97461374731210* Wire color


=== trans/manual_text_circular_dependency ===

$29050562435902*
A circular dependency is when the input of a component changes based on its own output. 

[center][img]res://dialogue/circular_dependency.png[/img][/center]

This simulator does not allow circular dependencies and instead triggers an error. 

The exception to this are the square pins that do not influence the output in the same tick. They can therefore not cause circular dependencies.

[center][img]res://dialogue/delay_buffer.png[/img][/center]


=== trans/manual_text_instructions ===

$24791538034329*
What this game calls an "instructions" is also known as an operation or an opcode (short for operation code). Regardless of the operating system, programming language or any other layers above it, all software must inevitably be reduced to instructions for the CPU to process them.

Internally in modern CPUs, instructions are translated into "microcodes", which are even smaller steps, out of reach for the programmer.


=== components/Xor32 ===

$66299093873977* 32 bit XOR
$38169019785615* Bitwise XOR two values


=== trans/level_alu2_text ===

$58359423026017*
[right]Code
[color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output
[/right]


=== trans/level_turing_complete_description ===

$74859324795927* [center]Add conditions to the calculation codes[/center]


=== components/LessU16 ===

$91783087669146* Checks if one input is less than the other
$33190791348214* Less (unsigned)


=== trans/level_nand_check ===

$32982011047799* Check


=== trans/level_complete_tooltip ===

$33922330743421*
[b]Wire color[/b]
[color=#cccccc][i]Keep your wires organized with colors.[/i][/color]


=== trans/level_odd_number_RichTextLabel2 ===

$28592851869484*
[right][color=#e49f44]Input 1
Input 2
Input 3
Input 4[/color]
Desired output
Current output[/right]


=== levels/push_pop ===

$78804623186243* OUTPUT
$49526452710191* DON'T POP
$58050047963238* VALUE
$19245209470436* Create a stack
$12227209887733*
Each tick the inputs will either signal PUSH or POP. If it is PUSH, store the value on top of the stack. When it is POP remove that value from the stack and output it.
	
The output has an enable pin, enable it only on POP.

$15662660252584* Do nothing
$62469306234943* DON'T PUSH
$46948857059388* POP value {value} off stack
$18761197388580* In order to cut spending, it has been decided to change the queuing system at public offices so that fewer people will go. Instead of first come, first served, we are implementing a last come first served policy. Think of it like a [color=#e49f44]stack[/color] of numbered slips where the citizens either put a slip on top (called [color=#e49f44]PUSH[/color]), or the bureaucrats take one off the top of the stack (called [color=#e49f44]POP[/color]). We want you to implement this new system.
$65188797398656* PUSH {value} on stack


=== trans/level_complete_robot ===

$73150174144736*
[b]Robotron 9000+[/b]
[color=#cccccc][i]Control [color=#e49f44]Robotron 9000+[/color] using your computer[/i][/color]


=== levels/The Product of Nibbles ===

$14957949958941* What you did here was actually multiplying two 4 bit numbers. We had the intern scale it up to bytes instead.
$19136817138607* [center]Multiply the 4 bit numbers[/center]
$13549246864135* Bit 0
$14533861483435* Multiplying two 4 bit numbers gives you a 8 bit number. Build a circuit that does this.
$10274387271390* Bit 0
$83694551809785* Multiply {num1} and {num2}


=== levels/byte_and ===

$15885763626223* Create a circuit that ANDs two bytes bitwise.


=== components/LessI64 ===

$42718501644862* Less (signed)
$19948786194409* Checks if one input is less than the other


=== components/ByteLessU ===

$68645721548287* Checks if one input is less than the other
$73502755965496* Less (unsigned)


=== main_scripts/functions ===

$11467644007149* Counter {nr}
$73560327420927* This save is from an obsolete version of this level.\nCreate and load a new schematic in the schematic menu.
$99285446909923* To solve this level you need to use the 'Level output' component
$72465734060414* Short circuit on wire (output values: {values})
$10533010562232* DELAY SCORE: {delay}
$10098517717617* Test: {nr} / {total}
$29225283986051* To solve this level you need to use the 'Level input' component
$95056157627313* To solve this level you need to use the 'Level input' component
$87591753278764* Reg {nr}
$29169064199243* Output {nr}
$12249248261034* To solve this level you need to use the 'Level output' component
$13327741293223* Input {nr}
$32508339206292* GATE SCORE: {gate}


=== ui/global_translations ===


# Instead of writing 5839000, the number turns into 5.8M
$22896492410578* M
$91472284749011* DELAY
$21803034737442* tick
$86260137015175* TICK
$44906330481241* Delay

# Instead of writing 5839, the number turns into 5.8K
$84696693690500* K
$22213999385406* delay
$30602804398798* Gate
$39343770421034* gate
$76763908762578* Tick
$15265492169229* GATE

# Instead of writing 5839000000, the number turns into 5.8B
$71072134093858* B


=== ui/toggles/level_log2 ===

$91515053618360* Manual


=== levels/or_gate_3 ===

$15448906128695* Create an OR gate with 3 inputs.


=== trans/binary_racer_count_down2 ===

$23959994711260* Ready to race?


=== trans/map_complete ===

$81337533438394* Complete


=== trans/levels_any_doubles_RichTextLabel2 ===

$60287131882436*
[right]Input 1
Input 2
Input 3
Input 4[color=#e49f44]
Desired output
Current output[/color][/right]


=== components/Shl16 ===

$79406691850426* Shift left
$34287811246049* Shifts the bits of an input left


=== trans/schematics_menu_visible_label ===

$34084132835354* Visible in menu


=== components/RegisterRedPlus ===

$57531353625235* Register


=== trans/level_saving_bytes_text ===

$43691912945654*
[right]Action
Desired state
Desired output
[/right]


=== trans/level_description ===

$26184794529449* [center]Add conditions to the calculation codes[/center]


=== components/Counter64 ===

$62528867413395* 64 Bit Counter
$62736827510023* Increments each tick, unless overwritten


=== levels/Storage cracker ===

$11910674853271*
The security access door to the storage room is broken and it keeps locking our old janitor inside.

The door keeps changing the passcode, we need a program that can recover the passcode at any time.
$17462419719036*
The easiest way to find the passcode would be to try all combinations until you find the right one. 
Although the broken mechanism does make a weird beep when your guess is too high, you might be able to use that to your advantage.
$11183892008673* You win this level when you output the correct passcode, no output will fail the level. Additionally, the input will be 1 after a guess that was too high and 0 otherwise.


=== trans/level_alu1_text ===

$53254733455389*
[right]Code
[color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output
[/right]


=== components/Output16 ===

$37381472194529* Output


=== trans/level_nand_1 ===

$71204033550134* What does the NAND gate do?


=== trans/manual_text_program ===

$25326551844839*
The program component is a read only memory component, that can have its data programmed in assembly. To edit the assembly, click on the yellow edit icon in the corner of the component.

[center][img]dialogue/manual/program_edit.png[/img][/center]

In the middle of the screen you will see the code area, read more about the assembly [color=#4d82c5][url=Assembly]here[/url][/color].

On the left hand side of the assembly editor interface, you can add assembly codes (mnemonics). Assembly codes act as a replacement for numbers, so instead of remembering what number represents the AND instruction in your architecture, you can add "AND" to your assembly codes, making code easier to read and write.

[center][img]dialogue/manual/assembly_codes.png[/img][/center]

On the program component you will also find the "Watch state" button. 

[center][img]dialogue/manual/watch_state.png[/img][/center]

This can be used to connect the assembly editor to registers, counters or probes. This way, the state of your architecture can be inspected as you write code, without closing the editor.


=== trans/options_cut ===

$88238310953306* Cut


=== components/Input 3 ===

$70689623552857* Input


=== components/Output32z ===

$73681609562628* Only outputs if the switch pin is [ON]
$92749186427039* Switched Output


=== trans/manual_text_top_truth ===

$83283949590490* AND gate


=== trans/and_gate_RichTextLabel2 ===

$98472849629373*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== trans/level_byte_equal_description ===

$38686097566531* [center]Check if the bytes are equal[/center]


=== components/Clock ===

$72088325385177* Clock


=== components/Xnor ===

$94079327237795* XNOR
$90614106399129*
[ON] when inputs are the same
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][ON][/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell]
[/table]


=== trans/tick ===

$92150881431937* Tick


=== components/1_decoder ===

$26685462633615* Toggles between two outputs
$98250587600120* 1 Bit decoder


=== components/XOR ===

$86856280609387*
[ON] when inputs are different
[table=5]
[cell]Input 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]Input 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]Output[/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]
$54832952840086* XOR


=== trans/options_undo ===

$58334563411624* Undo


=== trans/options_robot_down ===

$71118559743827* Down


=== components/Not16 ===

$17394768116288* 16 Bit NOT
$91053300263019* Bitwise negates 16 bits


=== trans/level_complete_manual_page ===

$39011561067359*
[b]Manual Entry[/b]
[color=#cccccc][i]RTFM[/i][/color]

Entry: [color=#68d277]Architectural complexity[/color]


=== misc/factory ===

$53123649343022* Component Factory


=== trans/level_complete_stat_level ===

$92313038380926* Level


=== trans/manual_network ===

$67416967652082* Network


=== trans/manual_ram ===

$61854681801183* Ram


=== trans/manual_header ===

$10757271456963* Manual entries


=== components/Ror16 ===

$13970397213910* Rotates the bits of an input right
$90115282457191* Rotate right


=== misc/opcode_name ===

$15090156481094* Name


=== trans/xor_gate_RichTextLabel2 ===

$21417732641222*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== trans/options_setting_program_alignment ===

$54874717650167* Program alignment warning


=== trans/map_cpu_architecture ===

$95559333192525* CPU ARCHITECTURE


=== components/ON ===

$96212935718484* Always [ON]
$95896157427528* ON


=== ui/top_bar/gate_score ===

$16224450605442* GATE SCORE:


=== misc/level_gate_unlocks_unknown ===

$76731326010721* Unlocks something unknown


=== misc/score_sync ===

$76911045833478* score sync


=== trans/levels_negative_header ===

$82195103144851* [center]Requirements[/center]


=== components/RegisterRed ===

$10081371413873* Register


=== trans/delete_confirm ===

$57294448765637*
Are you sure you want 
to delete this schematic?
$74657548486940* Yes


=== levels/byte_adder ===

$16888130664370*
If the result does not fit in 8 bits, turn the output carry [ON] (you can think of it as the 9th bit)
	
Finally, there is an input carry as well. This is useful for chaining together byte adders to add larger numbers. You can think of this carry as adding either 0 [OFF] or 1 [ON].

Use [color=#e63e5b][url=byte_adder]this hint[/url][/color] if you get stuck.
$18732877690173* Add the two input bytes. Each output bit in the output should be a result of the addition of the corresponding bits from the inputs, and potentially a carry.


=== components/Shr32 ===

$87104108203785* Shifts the bits of an input right
$88430124157796* Shift right


=== components/Mux32 ===

$16638728645850* Toggles between two values
$21257226547838* 32 Bit Mux


=== levels/saving_gracefully ===

$12474728041023*
The Delay Line only allows us to save a value for 1 tick. But sometimes a component that can save a value for longer periods of time is useful.

We want you to build such a component.
$13045361823397* DON'T SAVE
$13740696609075*
In this level you have 2 inputs.
When the first input is [ON], update the saved value.
The second input is the value.
Always output what is currently saved.
This is a diagram of the component we want you to build:

[img]dialogue/saving_gracefully/bit_memory.png[/img]


Check [color=#e63e5b][url=saving_gracefully]this hint[/url][/color] if you get stuck.



=== trans/levels_bytw_or_text ===

$21877344150481*
[right]
[color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output
[/right]


=== trans/level_unseen_fruit_description ===

$96313037592447* [center]Use the robot to scan the fruit[/center]


=== components/DelayLine64 ===

$80000130396288* 64 Bit Delay Line
$35525647389906* Outputs this tick's input, next tick


=== trans/manual_Cyclic recipes ===

$45682345144408* Circular recipes


=== trans/nor_gate_RichTextLabel2 ===

$52955821161579*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output[/right]


=== trans/instructions_the_robot ===

$26621808961883*
[color=#e49f44]0[/color] Move right
[color=#e49f44]1[/color] Move down
[color=#e49f44]2[/color] Move left
[color=#e49f44]3[/color] Move up
[color=#e49f44]4[/color] Enjoy the moment
[color=#e49f44]5[/color] Use action [color=#a9a9a9](enter)[/color]
[color=#e49f44]6[/color] Shoot laser [color=#a9a9a9](tab)[/color]


=== main_scripts/dialogue ===


# hint for odd number
$68750974209145* You can figure out if 2 inputs have an odd number of [ON] with just 1 component...

# hint for the bus
$50799425816171* Use switches to put the inputs on the same wire.

# Hint for byte switch
$86319296925137* What would this look like if you were only switching 1 bit? What would the truth table for such a component look like?

# Hint for byte adder
$37093555217568* You only need 8 full adders.

# Hint for the maze
$36837749971886*
Always following the left (or right) hand side of the maze will make sure you eventually reach the exit.
	
The pseudo code for such an algorithm looks like this:
 Step forward
 Turn left
 Turn right as long as there is a wall ahead
 Press use after each turn (in case the exit is ahead)
 Repeat

# hint for counting signals
$21044442262778* The circuitry for the 1's bit is the same as what you did in the level "Odd Number of Signals". The circuitry for the 2's bit is what you did in "Double Trouble", except when all 4 are on.

# hint for saving gracefully
$25321701584378*
In this level you need to use 1 Delay Line. Make a truth table for what should go into the Delay Line. Consider the input to the Delay Line as the output for your table. 

The inputs are the 2 level inputs AND the output of the Delay Line, as the output plays a role in its input. In total you have 3 "inputs" to for this table which gives you 8 combinations. Once you have the level requirements as a table, it should be a lot easier to solve.

# Hint for conditions
$87674181578455*
There are 3 condition bits. The first bit being [ON] means the result being 0 meets the condition. The second bit being [ON] means the result being less than 0 meets the condition. If either of those two are [ON], the condition is met. 
Finally, if the last bit is [ON], negate the status of the condition being met or not.

# hint for xor gate
$88963098241493* This level can be done with 3 components, a NAND, an AND and an OR gate.

# Hint for masking time
$46866534894828*
In binary, taking modulo 4 of a number is the same as only using the two lower bits. This is because the higher bits represent 4, 8, 16 etc, and they all divide 4 with no remainder.
This is true in general for modulo a power of 2, the lowest bit of a number represents that number modulo 2 (even or odd), the lowest 3 bits modulo 8 and so on.

Likewise, in decimal 4321 modulo 100 is also simple (answer is 21, the higher digits are disregarded), this is because 100 is a power of 10.

Now you just have to figure out how to get the last 2 digits of a number.

# hint for less
$56438995128380*
First determine which bits are different between the 2 bytes. This can be done using a byte XOR (remember XOR turns [ON] when the inputs are not the same). We know the number that has the highest different bit [ON] is the larger number. But we must only consider the highest different bit, so for each bit, use a chain of OR gates to check if any higher are [ON].
		
Finally, the last bit is considered separately for signed numbers, here it has the opposite effect (if only one number has it [ON], that number is guaranteed to be lower)


=== components/Nand32 ===

$24565725389553* Bitwise NAND two values
$71611588991682* 32 Bit NAND


=== trans/manual_text_edit_instructions ===

$75786562031150*
After you complete the level "Turing Complete" the instruction panel allows you to manually edit instructions. This is useful if you wish to build your own computers.

If you just finished the OVERTURE computer and see something weird, odds are you may have changed the definitions.

Each row has a label and 8 bits you can set to either[img]dialogue/on.png[/img], [img]dialogue/off.png[/img] or [img]dialogue/any.png[/img] (wildcard). When using the instruction panel, if the bitpattern matches a row, the label will be shown.


=== trans/options_robot_controls ===

$44632988778557* Robot controls


=== components/Rol32 ===

$88734684504266* Rotates the bits of an input left
$83642246004160* Rotate left


=== trans/odd_number_error ===

$61530231182650* Too many components used


=== components/ByteAnd ===

$61791872137683* Bitwise AND two values
$21541105796357* 8 Bit AND


=== trans/options_code_font_size ===

$98135524286922* Code font size


=== components/Counter ===

$51446864816252* Increments each tick, unless overwritten
$67910883947749* 8 Bit Counter


=== trans/ide_assembly_codes ===

$62016169253008*
[center]Assembly
codes[/center]


=== trans/options_general_title ===

$21908594290225* General


=== levels/binary_start ===

$19099025738142* Start


=== components/Keyboard ===

$40965596602414* Keyboard
$76766452660421* Records keypresses from your physical keyboard


=== trans/level_byte_xor_text ===

$15756501406553*
[right]
[color=#e49f44]Input 1
Input 2[/color]
Desired output
Current output
[/right]


=== trans/manual_edit_instructions ===

$86365051641280* Edit instructions


=== components/Input1_1B ===

$10517158300617* Level input
$57868504368581* Loads the input from levels


=== trans/manual_text_network ===

$70445160410129*
[b]Overview[/b]
The "Network" component gives you low level access to networking. In general you manipulate your network by sending the component [color=#e49f44]Requests[/color] and when update [color=#39aa49]Events[/color] return from the network they get queued up and you process them one at a time. To keep track of different simultaneous connections [color=#dd6576]Connection ID[/color]s are used.

These are the request types you can send to the component and their arguments:
[code]0[/code] No request
[code]1[/code] [color=#e49f44]Listen[/color] ([color=#dd6576]Port[/color])
[code]2[/code] [color=#e49f44]Connect[/color] ([color=#dd6576]IP[/color], [color=#dd6576]Port[/color])
[code]3[/code] [color=#e49f44]Send data[/color] ([color=#dd6576]Connection ID[/color], [color=#dd6576]Data[/color], [color=#dd6576]Data length[/color])
[code]4[/code] [color=#e49f44]Close[/color] ([color=#dd6576]Connection ID[/color])
[code]5[/code] [color=#e49f44]Read next event[/color]
[i]See component panel for which pin correspond to which argument.[/i]

Request types [color=#e49f44]Listen[/color] and [color=#e49f44]Connect[/color] outputs the [color=#dd6576]Connection ID[/color] of the new connection.

For 2 programs to [color=#e49f44]Send data[/color] to each other, one program must first [color=#e49f44]Listen[/color] (called a server) on a [color=#dd6576]Port[/color] and the other must then [color=#e49f44]Connect[/color] (called a client), using the [color=#dd6576]IP[/color] of the listening program and the [color=#dd6576]Port[/color] it selected. Once the connection is established, the server and client function exactly the same.

Notice an [color=#dd6576]IP[/color] is a 32 bit number, normally written as 4 bytes with dots in between (example: 127.0.0.1). In this simulator you reverse the order of the bytes, so 127.0.0.1 becomes 0x0100007F. 0x0100007F is always your computers loopback address and you can use this to connect programs running on the same computer.

You can detect when events happen on the network, by checking the "Next event type" pin. These are the event types:
[code]0[/code] No event
[code]1[/code] [color=#39aa49]Incoming connection[/color] ([color=#dd6576]Connection ID[/color], [color=#dd6576]Port[/color])
[code]2[/code] [color=#39aa49]Connect complete[/color]
[code]3[/code] [color=#39aa49]Receive data[/color] ([color=#dd6576]Connection ID, Data[/color], [color=#dd6576]Data length[/color])
[code]4[/code] [color=#39aa49]Connection closed[/color] ([color=#dd6576]Connection ID[/color] / [color=#dd6576]Error code[/color])

[color=#39aa49]Incoming connection[/color] only happens after a [color=#e49f44]Listen[/color]. Use the [color=#dd6576]Port[/color] to distinguish between listeners (it is not possible to listen to the same port twice at the same time).

[color=#39aa49]Connect complete[/color] only happens after a [color=#e49f44]Connect[/color], wait for this before you start sending data.

You may send or receive between 1 and 8 bytes of data at a time, use the [color=#dd6576]Data length[/color] to decide.

A connection may be either "possibly open" or "closed". There is no way to know if a connection is actually open other than sending data. The underlying network protocols were designed like this for reliability and speed, it is not a limitation of the simulator.

If you get a [color=#dd6576]Connection ID[/color] of -1, this means there was an error connecting.


=== levels/unseen_fruit ===

$13023474026617*
The most noteworthy thing on your planet is the fruit. It is very tasty.

That's why we are having a fruit tasting event in the canteen.
$14259900563789* Scan the conveyor belt for the fruit incoming at regular intervals. As soon as you have see the same kind of fruit twice, turn and press the control panel.
$17070232883226* But we want to make sure we don’t get the same fruit twice as that would obviously be embarrassing.


=== ui/toggles/negative_numbers ===

$50924073287410* Toggle number format


=== levels/conditions ===

$12951779797594*
This level has a value input and 3 condition bit inputs.

The 3 bits select the condition as shown below. Check the value against the selected condition and output [ON] if it is satisfied and [OFF] otherwise.

Bit code:        Turn [ON] when:[code]
[OFF] [OFF] [OFF]    Never
[OFF] [OFF] [ON]    If value = 0
[OFF] [ON] [OFF]    If value < 0
[OFF] [ON] [ON]    If value ≤ 0
[ON] [OFF] [OFF]    Always
[ON] [OFF] [ON]    If value ≠ 0
[ON] [ON] [OFF]    If value ≥ 0
[ON] [ON] [ON]    If value > 0[/code]
$16407231803964* If VALUE < 0 output [img]dialogue/on.png[/img]
$16742265812068* Regardless of VALUE output [img]dialogue/on.png[/img]
$17616699231679* If VALUE > 0 output [img]dialogue/on.png[/img]
$16632557438774* If VALUE ≠ 0 output [img]dialogue/on.png[/img]
$18234235689107* If VALUE ≥ 0 output [img]dialogue/on.png[/img]
$12429396872036* Regardless of VALUE output [img]dialogue/off.png[/img]
$19014698800906* If VALUE = 0 output [img]dialogue/on.png[/img]
$13680487623452* If VALUE ≤ 0 output [img]dialogue/on.png[/img]
$12706881725738* Your circuit has been saved to the component factory.


=== misc/factory_back_inner ===

$12211557416281* Back


=== components/ByteShl ===

$74488427658653* Shift left
$66482114876737* Shifts the bits of an input left


=== trans/manual_instructions ===

$90323246286028* Instructions


=== trans/schematics_description ===

$39347262933523* Description


=== levels/and_gate ===

$15232844525838*
Create the circuit that matches the table.
	
[tip]Double click on a component to move it together with connected wires.[/tip]
$15231724707514* I don't want to discourage you, but I think the elephant will win the competition. No offense but your brain is tiny in comparison.


=== trans/level_component_factory_error ===

$49014901714855* Map squares can only contain one input or output node.


=== trans/level_ram_component_RichTextLabel2 ===

$92123299522120* [center]Expected states[/center]


=== trans/nand_Label ===

$11482037025960*
Input 1


Input 2


=== components/Add16 ===

$28092601427278* Adds two inputs
$30820974870562* Add


=== trans/options_working ===

$18749833316380* Working


=== trans/options_robot_use ===

$49182380646128* Use


=== components/MemoryProbe ===

$46948613505134* Display a value on your custom component or in the program editor
$44867305035474* Memory Probe


=== trans/manual_text_rgb ===

$52915933943906*
This simulator uses 3 byte RGB colors for some components. Color are 1 byte each, the byte value determining the intensity of each color: 
[color=#e3243f]RRRRRRRR[/color][color=#55ff55]GGGGGGGG[/color][color=#3333ff]BBBBBBBB[/color]


=== trans/map_working_computer ===

$38843517090942* WORKING COMPUTER


=== components/Not32 ===

$33620523355085* 32 Bit NOT
$24607331341411* Bitwise negates 32 bits


=== misc/StateProbe ===

$54427436420428* Wire Probe
$15969687819995* Display a value on your custom component or in the program editor


=== levels/sr_latch ===

$11150103897185*
In this level, components may depend on themselves or form loops of up to two components. Despite depending on their own output, some of these wires have stable outputs, at least for some inputs.

The circuit you are asked to construct here has a circular dependency. The circuit also has 2 "stable states" for most inputs. A stable state here means that every component's output agrees with its input. As an example, an OR gate with one input disconnected and the other connected to its own output is stable. If the output is [OFF], both inputs are [OFF], which agrees with the OR gate. If the output is [ON], then so is one of the inputs. However, a NOT gate connected to its own input is not stable. If the output is [ON], then the input is [ON] as well. This will cause the NOT gate to try and make the output [OFF], which will also make the input [OFF]. The circuit will switch between these two states forever, so it is not stable.
$18165461234561* Delay lines are easy to understand and can be used to build any computer architecture. However, modern hardware no longer use these as a basis for memory.
$15754153332116* This level introduces the concept of latches. This mechanic is not necessary to complete the game.
$15213907597666* Using 2 NOR gates, build the circuit that matches the table. You will need a latch.
$19448398663695*
When we want to determine what components in a circular dependency are outputting, we don't have a first component we can start with. Instead we use the values of the wires from last tick. This is because in real hardware electrons don't travel instantly. Depending on the circuit, the wires either flicker between [ON] and [OFF], or settle in a stable state.
	
When you have a circuit where the wires can settle in either of 2 different stable states, you have a basis for memory. The next state will depend on the values the wires had last tick. Such wires are called "latches".


=== trans/complete_unlocks ===

$45250062735373* Unlocks


=== components/FastRam ===

$79436020115192* Fast but high gate cost memory
$12924829814634* Fast RAM


=== levels/byte_xor ===

$19636386696963* Create a circuit that XORs two bytes bitwise.


=== trans/level_RichTextLabel2 ===

$12683441099336*
[right]Input 1
Input 2
Input 3
Input 4[color=#e49f44]
Desired output
Current output[/color][/right]


=== trans/manual_program ===

$91120798735036* Program


=== levels/Immediate Values ===

$64348543296709* Linked component {value} should point to the output
$14060810229477* Add 6 registers to the map
$79667526283284* Linked component {value} should point to the counter
$14960344494328*
Sometimes it is useful to load a value directly from the program instead of from registers. This is called loading an immediate value. In the [color=#e49f44]LEG[/color] architecture we signal when we want to do this directly in the opcode. We can do that in the following way:
	
When the 8th bit of the opcode is [ON], use argument 1 as an immediate value, instead of as a register address.
When the 7th bit of the opcode is [ON], use argument 2 as an immediate value, instead of as a register address.
	
		[img]dialogue/leg_diagram.png[/img]
		

$10788301006338* Linked component {nr} should point to a register or custom component with a register inside
$19338533633006* Set the counter increment to 4
$15197362332657* Create a new schematic and add a program with 4 byte output
$18004215603701* Add a counter to the circuit
$10141611261952* [center]Implement immediate values[/center]


=== components/switch ===

$87345192339084* Toggles a value
$29301846684808* 8 Bit Switch


=== components/Register64 ===

$86007777261800* 64 Bit Register
$99461037008796* 64 bit memory


=== levels/Wire Spaghetti ===

$29329105515650* Add 1 more register to the map
$17106892574116* Add a counter to the circuit
$50177586789991* Add {nr} more registers to the map
$15754373587500* Set the counter increment to 4
$56024330661504* Linked component {nr} should point to a register or custom component with a register inside
$19099471819164*
The following are the set up steps that needs to be done in order to complete this level:
		
[b]1.[/b] Click the schematic icon ([b][i][/i][/b]) and create a new empty architecture.
[b]2.[/b] Place a program block with 4 outputs.
[b]3.[/b] Place a counter, set its increment to 4 and connect it to the program block.
[b]4.[/b] Add 6 registers (or custom components with registers)
[b]5.[/b] Click "Edit link components" on the program component and connect registers to 0 to 5. Connect the counter to 6 and the output to 7.

$18860645759682*
The [color=#e49f44]LEG[/color] architecture is a computer that takes 4 bytes per tick from the program. 

The first byte describes the operation (called the [color=#e49f44]OPCODE[/color]).

Since many operations take 2 arguments (like ADD, OR etc), the second and third byte are for arguments.

And since most operations return 1 result, the fourth byte is for the result.
	
	[img]dialogue/leg_diagram_1.png[/img]
$11377431500625* Add 6 registers to the map
$14051336765362* Finally it is time for you to start building the [color=#e49f44]LEG[/color] architecture!
$13268807052125* (You might be adding 7+7, but here 7 means load from input and the input has value 8)
$30006055126224* Linked component {output} should point to the output
$19066122929275* [center]Set up registers and implement the ADD opcode[/center]
$10912834168905*
Finally, in this level the [color=#e49f44]OPCODE[/color] is always 0. This means we ADD argument 1 and argument 2 and save the result to the destination.

The value of an argument or destination refers to one of these places:
[code]
[color=#e49f44]0[/color]: Register 0
[color=#e49f44]1[/color]: Register 1
[color=#e49f44]2[/color]: Register 2
[color=#e49f44]3[/color]: Register 3
[color=#e49f44]4[/color]: Register 4
[color=#e49f44]5[/color]: Register 5
[color=#e49f44]6[/color]: Counter
[color=#e49f44]7[/color]: Input/Output
[/code]

In the next level you will implement more [color=#e49f44]OPCODES[/color], which will require a different ALU than that of [color=#e49f44]OVERTURE[/color].


$10922418807673* Argument 7 means read from input, but input is not enabled.
$62258842382434* Linked component {counter} should point to the counter
$18769284297247* Create a new schematic and add a program with 4 byte output


=== trans/schematic_new_file_name ===

$24424463568668* New schematic


=== trans/options_resubmit ===

$13328644005279* Resubmit


=== trans/negative_numbers ===

$57872971841486* Negative numbers


=== trans/level_bit_adder_RichTextLabel2 ===

$79624864981341*
[right][color=#e49f44]Input 1
Input 2[/color]
Desired Sum
Desired Carry
Current Sum
Current Carry[/right]


=== components/Output8zLevel ===

$49513138880387* Output


