$14973719570693* Add a counter to the circuit
$16826220977157*
 [color=#b72d41][b]TIP:[/b][/color] 
COPY is just ADD with the second argument being 0
$14690660047411* Implement the condition opcodes
$11252365204151* Create a circuit that outputs [ON] when the first input is less than the second. Interpret the bytes as being [color=#dd6576]UNSIGNED[/color].
$10633476398156*
Create a circuit that can [SAVE] or [LOAD] a byte.

When the first input bit is [ON], [LOAD] the memory and send it to output.
When the second input bit is [ON], [SAVE] the input byte.

The output has an enable pin, enable it only on [LOAD].

$19416009887091*
Sometimes it is useful to reuse a section of code. We call these sections "functions". To implement this reuse, one can [color=#e63e5b][url=terminology]jump[/url][/color] to the beginning of the function and jump back again at the end of the function. We call jumping to the function "calling" the function, and jumping back from the function "returning" from the function. 
	
But for this section of code to actually be reusable, the return jump will have to be able to return to different locations, depending on where we called the function from.

We could save the counter value to a register before jumping to the function and use this value when returning. However, if done this way, a function would not be able to call another function, since this would overwrite the original return address.

Say function A calls function B, who calls function C. When we want to return from C, we only need the return address for B and in B we only need the address for A. In general, regardless of which function we look at and how they are nested, the last return address we added is always the first one we will need again. This is exactly the behavior of the stack.
$15463931654475* [center]Add "call" and "ret" instructions[/center]
$12227209887733*
Each tick the inputs will either signal PUSH or POP. If it is PUSH, store the value on top of the stack. When it is POP remove that value from the stack and output it.
	
The output has an enable pin, enable it only on POP.

$14533861483435* Multiplying two 4 bit numbers gives you a 8 bit number. Build a circuit that does this.
$15885763626223* Create a circuit that ANDs two bytes bitwise.
$32508339206292* GATE SCORE: {gate}
$17070232883226* But we want to make sure we don’t get the same fruit twice as that would obviously be embarrassing.
$12951779797594*
This level has a value input and 3 condition bit inputs.

The 3 bits select the condition as shown below. Check the value against the selected condition and output [ON] if it is satisfied and [OFF] otherwise.

Bit code:        Turn [ON] when:[code]
[OFF] [OFF] [OFF]    Never
[OFF] [OFF] [ON]    If value = 0
[OFF] [ON] [OFF]    If value < 0
[OFF] [ON] [ON]    If value ≤ 0
[ON] [OFF] [OFF]    Always
[ON] [OFF] [ON]    If value ≠ 0
[ON] [ON] [OFF]    If value ≥ 0
[ON] [ON] [ON]    If value > 0[/code]

$15754153332116* This level introduces the concept of latches. This mechanic is not necessary to complete the game.
$15213907597666* Using 2 NOR gates, build the circuit that matches the table. You will need a latch.
$19448398663695*
When we want to determine what components in a circular dependency are outputting, we don't have a first component we can start with. Instead we use the values of the wires from last tick. This is because in real hardware electrons don't travel instantly. Depending on the circuit, the wires either flicker between [ON] and [OFF], or settle in a stable state.
	
When you have a circuit where the wires can settle in either of 2 different stable states, you have a basis for memory. The next state will depend on the values the wires had last tick. Such wires are called "latches".
$18004215603701* Add a counter to the circuit
$56024330661504* Linked component {nr} should point to a register or custom component with a register inside
$19099471819164*
The following are the set up steps that needs to be done in order to complete this level:
		
[b]1.[/b] Click the schematic icon ([b][i][/i][/b]) and create a new empty architecture.
[b]2.[/b] Place a program block with 4 outputs.
[b]3.[/b] Place a counter, set its increment to 4 and connect it to the program block.
[b]4.[/b] Add 6 registers (or custom components with registers)
[b]5.[/b] Click "Edit link components" on the program component and connect registers to 0 to 5. Connect the counter to 6 and the output to 7.
$11377431500625* Add 6 registers to the map
$62258842382434* Linked component {counter} should point to the counter