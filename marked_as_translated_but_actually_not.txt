In this level you need to create a wire which can copy from a [color=#c54d5e]source[/color] to a [color=#e49f44]destination[/color].
The instruction byte in this level determines the [color=#c54d5e]source[/color] and the [color=#e49f44]destination[/color].
Bits 1, 2 and 3 give the [color=#e49f44]destination[/color]. Bits 4, 5 and 6 give the [color=#c54d5e]source[/color].
$16810715868480* [center]Calculate modulo 4 of the input.[/center]
$10866019808027* For this level you probably want to turn on signed numbers, so the highest bit shows as -128. Click
$18189600217529* [center]Implement the OPCODE instructions[/center]
$11038144815919* This level uses programs to test your wires. When the programs are run, this level checks if the
$16072814175447* Programming on buggy hardware is very frustrating. It is painful to suddenly be forced to reason about wires, when you are in the middle of solving a programming problem. It is tempting to apply a quick wire fix, so you can get back to solving the original problem. But now this quick fix broke something else in a program that used to work and so on. Therefore, when developing hardware try to aim for 100% reliability before you start programming!
$14458828731919* Time to merge in the
$16133643476631* The wire you built in the
$12671132029272* Your wire has been saved to the component factory.
In this level you only get one input, we call this the initial seed. The seed is put through the following steps to produce a pseudo random number.
In the algorithm below,
Components are available in the menus on the right side. Once placed, click on the pins of the components and drag to connect them with wire. On the left you will find the UI for the simulation control. Note that you can right click on the "Run faster" button to set target speed.
You can find more information about the simulation in the manual (button is in the top left). Notable features to check out are the "component factory" where you can create your own components and the program component, which lets you define your own assembly.
$19454393978813* The Keyboard lets you directly control your computer, using well... your keyboard
Add if statements to your wire. For the if statements, the 2 arguments are compared and if the condition is true, the counter is set to a jump address.
The previous instructions had the 4 bytes represent:
For if statements the bytes represent:
In addition to the previous opcodes, add:
Use unsigned less / greater for the comparisons.
Each opcode does what their name implies. For example the following jumps to byte 16 if REG0 is less than REG1:
$14973719570693* Add a counter to the wire
 COPY is just ADD with the second
 argument being 0
$14690660047411* [center]Implement the condition opcodes[/center]
$11252365204151* Create a wire that outputs [ON] when the first input is less than the second. Interpret the bytes as being [color=#dd6576]UNSIGNED[/color].
Create a wire that can [SAVE] or [LOAD] a byte.
When the first input bit is [ON], [LOAD] the memory and send it to output.
When the second input bit is [ON], [SAVE] the input byte.
$19416009887091* Sometimes it is useful to reuse a section of code. We call these sections
$15463931654475* [center]Add
        [img]dialogue/delay_buffer.png[/img]
$12227209887733* Each tick the inputs will either signal PUSH or POP. If it is PUSH, store the value on top of the stack. When it is POP remove that value from the stack and output it.
$14533861483435* Multiplying two 4 bit numbers gives you a 8 bit number. Build a wire that does this.
$15885763626223* Create a wire that ANDs two bytes bitwise.
$32508339206292* NAND SCORE: {nand}
[img]dialogue/saving_gracefully/bit_memory.png[/img]
$17070232883226* But we want to make sure we don’t get the same fruit twice as that would obviously be embarrassing.
This level has a value input and 3 condition bit inputs.
The 3 bits select the condition as shown below. Check the value against the selected condition and output [ON] if it is satisfied and [OFF] otherwise.
Bit code:        Turn [ON] when:[code]
[OFF] [OFF] [OFF]    Never
[OFF] [OFF] [ON]    If value = 0
[OFF] [ON] [OFF]    If value < 0
[OFF] [ON] [ON]    If value ≤ 0
[ON] [OFF] [OFF]    Always
[ON] [OFF] [ON]    If value ≠ 0
[ON] [ON] [OFF]    If value ≥ 0
[ON] [ON] [ON]    If value > 0[/code]
This level introduces the concept of latches. This mechanic is not used anywhere else in the game. However, this level is here for the sake of completeness.
If you do not have experience with electronics, it is recommended that you skip this level. You can always come back later.
$15213907597666* Using 2 NOR gates, build the wire that matches the table. You will need a latch.
When we want to determine what components in a circular dependency are outputting, we don't have a first component we can start with. Instead we use the values of the wires from last tick. This is because in real hardware electrons don't travel instantly. Depending on the wire, the wires either flicker between [ON] and [OFF], or settle in a stable state.
When you have a wire where the wires can settle in either of 2 different stable states, you have a basis for memory. The next state will depend on the values the wires had last tick. Such wires are called "latches".
$18004215603701* Add a counter to the wire
$56024330661504* Watched state {watched_state} should point to a register or custom component with a register inside
The following are the set up steps that needs to be done in order to complete this level:
[b]1.[/b] Click the schematic icon ([b][i][/i][/b]) and create a new empty architecture.
[b]2.[/b] Place a program block with 4 outputs.
[b]3.[/b] Place a counter, set its increment to 4 and connect it to the program block.
[b]4.[/b] Add 6 registers (or custom components with registers)
[b]5.[/b] Click
$11377431500625* Add 6 registers to the map (or 6 custom components with only 1 register inside each)
$62258842382434* Watched state {value} should point to the counter