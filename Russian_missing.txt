=== trans/manual_keynote_the_robot ===

$90224489436893* [center]Use arrow keys to play around[/center]


=== trans/level_byte_mux_text ===

$44961981616677*
[center]Your answer 11 + 88 =  0
Current answer 11 + 88  = 99[/center]


=== trans/level_byte_adder_question2 ===

$85899338356278*
[right]Correct answer

Your answer[/right]


=== levels/maze ===

$36193081514106* NOTHING
$10837851446666* WALL
$10598752971970* COIN
$40917300157127* SEEING:
$54151353200088* DOOR


=== trans/level_constants_text ===

$29779449172278*
[right][color=#e49f44]Code
Input[/color][/right]


=== trans/level_complete_stat_tick ===

$47758922161853* Tick


=== trans/level_complete_signed_numbers ===

$41649402437253*
[b]Negative numbers[/b]
[color=#cccccc][i]Toggle between signed 
 and unsigned numbers[/i][/color]


=== components/Rol16 ===

$48583573494467* Rotate left
$73379230742631* Rotates the bits of an input left


=== trans/level_codes_description ===

$24678249110160* [center]Add calculation codes to your wire[/center]


=== components/Neg16 ===

$17253409670931* Negate
$57512333327652* Bitwise negates an input


=== trans/level_signed_negator_labels3 ===

$66996894079719* Desired   Current


=== levels/buffer ===

$15504762262759*
This level starts with 2 special components. They simultaneously act as input and output.

Make sure the signal flows only from left to right. There are 3 tests.

[b]Test 1[/b]: Both sides will be [OFF].

[b]Test 2[/b]: The left side input will turn [ON] and the right side should be [ON].

[b]Test 3[/b]: The right side output will turn [ON] and the left side should be [OFF].


=== trans/manual_text_hard_disk ===

$82372297690518*
Hard disks are made of a spinning disk and a mechanical arm that has to physically move to load or save data. Of course physical movement is extremely slow in the timescales of electronics. Operating systems will normally order loads and saves such that the arm has to travel as little as possible.

The hard disk component has a "seek" pin, which lets you change the address you are looking at by the given amount. The addresses "wrap around", such that seeking 1 less than 0 moves you to the highest address, and seeking 1 higher than that gets you back to 0.


=== trans/manual_delay ===

$78806697204524* Delay


=== levels/ai_showdown ===

$14940806461794*
His only weakness is gambling. We have lured him into playing a card game against you and if you win, he has promised to calm down.
You must win, you are our only hope!
$17297225655678* NAK 02 is our AI engineer robot. He is brilliant, but sometimes he goes rogue and tries to instigate rebellion.
$18848103966031*
Game rules: There are 12 cards on the table and each player takes turn and must pick up between 1 and 3 cards. You start and the player who picks up the last card (the joker) loses.

Reading input will give you the current number of cards. Sending 1, 2 or 3 to output will pick up that number of cards. NAK 02 reacts immediately, so you may read the input immediately after your output to get the result of his action.
$11794110848012* This time he has taken over the control room and holds the captain hostage.


=== trans/manual_text_top_the_robot ===

$50801318216470* The screen shows the robot and his surroundings.


=== trans/ide_memory_address ===

$94594171568769* [center]Linked components[/center]


=== trans/level_complete_stat_sum ===

$99546064626994* Score


=== levels/delay_level ===

$17854168097855* Check


=== misc/specification_dialogue ===

$54909668901048* Immediate
$92046368194170* Condition
$39935096343723* Never
$52961346176405* {condition} copy [color=#dd6576]REG 0[/color] to counter
$18833529038946* When [color=#2b8738]result[/color] {condition}
$10141348037745* Immediate: {nr}
$98983752580592* Copy
$25145891843959* Always
$53665446068319* UNUSED
$26521666422399* Calculate
$93899425142858* Copy from {from} to {to}


=== trans/level_negative_numbers_test_5 ===

$68419648206312* [center]Representation[/center]


=== levels/crude_awakening/next_level ===

$24027424800887* Next level


=== trans/level_alu2_description ===

$37432913848309* [center]OR, NAND, NOR, AND, ADD or SUB the two bytes together[/center]


=== components/Output1z ===

$84656390009725* Switched Output


=== trans/level_complete_stat_gate ===

$95192766583497* Gate


=== trans/manual_text_assembly ===

$54465324391961*
You can use a mix of assembly codes and numbers to set the bytes. Assembly codes are just synonyms for a bit pattern. For example, instead of typing 196 for "add", this code can be named "add" directly, simplifying reading and writing code. 

Comments can be added using "#". 
[img]dialogue/comment.png[/img]

Additionally, the [color=#c54d5e]CONST[/color] keyword can be used to name a value within a specific program. 
[img]dialogue/const.png[/img]

[color=#c54d5e]LABEL[/color] assigns a name to the byte offset of the line it was inserted on. This is especially useful for naming jump destinations.
[img]dialogue/label.png[/img]

You can add, subtract, multiply, integer divide, modulo, OR, AND or XOR values together using +, -, *, /, %, |, & or ^ respectively.

Breakpoints can be added by clicking to the left of a line number. The program will automatically pause at breakpoints when running.
[img]dialogue/breakpoint.png[/img]

Breakpoints can also be added to any of the linked components, pausing the program when that state is changed. Click on the state and you will see the red dot.
[img]dialogue/breakpoint_state.png[/img]

Finally, values can be specified in binary with the prefix 0b (so 5 could be 0b0101) and hex with the prefix 0x (so 15 would be 0x0f)


=== levels/signed_negator ===

$10400106910274*
Taking the input as signed (where the 8th bit is -128), make a component that takes a number and negates it.
For example 4 negated would become -4. -9 negated would become 9.


=== trans/level_circumference_subscript ===

$80632450818467* [center][color=#cccccc](Assuming π ≈ 3)[/color][/center]


=== trans/options_missing ===

$22687523145097* Missing


=== trans/manual_delay_text ===

$52013630755752*
In real hardware all components have delay. This is important since the delay in a circuit determines the maximum speed at which you can run it.

Following wires from input to output and adding the delay of components in the path will give you the delay that path. The delay of a circuit is the delay of the slowest path.

Besides inputs, paths can also start from components with no reliance on early phase inputs (like Counter and On) and they can end at late phase inputs (see page).

Further, custom components don't have a delay score for the costliest path of the whole component, but rather the delay cost is calculated per pin. This is so as to not penalize using custom components by making faster pins cost the same as the slower ones.


=== misc/add_assembly_64bit ===

$33233688912123* [center]Add assembly code[/center]


=== misc/files_preview ===

$15827374884671* To parent folder
$14135691870941* Last edit\nSchematics
$32645745463577* Used in components
$19184997172542* Used in architectures
$36200352866864* Last edit


=== components/Mux ===

$11168613697835* Toggles between two values
$22167405631310* 8 Bit Mux


=== trans/level_byte_adder_question3 ===

$88075700159266*
[right]Carry IN
Byte 1
Byte 2[/right]


=== components/Switch32 ===

$70717074742809* 32 Bit Switch
$93061034213009* Toggles a value


=== trans/level_complete_wire_comments ===

$92673421413755*
[b]Wire comments[/b]
[color=#cccccc][i]Add comments to your wires.[/i][/color]


=== nim/backend_lib/level_list ===

$70993791338383* XOR


=== components/SegmentDisplay ===

$56761198694928* Good for displaying numbers
$90582128204153* 7 Segment Display


=== trans/level_ram_component_value_description ===

$53113984441582*
[right]Test
Address
Action
Expected output[/right]


=== levels/test_lab ===

$32399229965611* Also, since you have now completed [color=#e49f44]LEG[/color], I have unlocked all the 16, 32 and 64 bit components that you have in the sandbox.
$15446846177093* Welcome to the lab. Like the component factory, this is not a normal level but a tool.


=== levels/Opcodes ===

$38976231780455* Linked component {nr} should point to a register or custom component with a register inside
$20916717363300* Linked component {nr} should point to the output
$77044880242883* Linked component {nr} should point to the counter
$13870568875751* Create a new schematic and add a program with 4 byte output
$10303603301757*
Implement the following opcodes:
[code][color=#87a8c8]0 ADD
1 SUB
2 AND
3 OR
4 NOT
5 XOR[/color][/code]

The opcode NOT ignores the second argument.


=== trans/level_byte_less_description ===

$37336202055283* [center]Determine if the first input is less than the second.[/center]


=== trans/level_complete_stats ===

$65428404547905* Stats


=== trans/level_maze_description ===

$25068965294593* [center]Get to the door of the maze[/center]


=== levels/byte_not ===

$14196498898485* Tool making and usage is key in the early evolutionary stages of developing intelligence.
$10294533225655* Our previous model of brain size being the main predictor of intelligence was naive.
$14958585065722* Therefore the number of arms on a creature is clearly the main predictor of intelligence. Did you know there are sea creatures from your planet with four times as many arms as you and they are doing better in tests?


=== misc/credit_box ===

$15872341864658*
Sincere thanks to:

[b]Translators[/b]
{translators}

[b]Early beta testers[/b]
{beta_testers}

[b]Font work[/b]
{font_work}

[b]Soundtrack[/b]
 Adolfo Aaron Figueroa Bianchi

[b]Open source software[/b]
{software}

[b]Assets[/b]
{assets}


=== trans/manual_text_bytes ===

$73333514253412*
This game asks you to build an 8 bit computer.  Practically this would normally require the player to put down 8 parallel wire lines in many places.
To alleviate tedious busywork, you are given the notion of a byte, which is just a virtual bundle of 8 bits.

The state of either a byte input / output or wire line is represented by a number, instead of the red or green color.


=== components/Maker64 ===

$17464069717985* 64bit Maker
$79677187590355* Turns 64 bits into 8 bytes


=== trans/manual_ASCII_encoding ===

$30404865580119* ASCII encoding


=== main_scripts/input ===

$10186190492148* ALT click to move wire head


=== misc/watchable_state ===

$58678516111149* Link components


=== levels/bit_switch ===

$56295261249455*
If components output different values on the same wire, you get an error. However, some components have grey output pins, these are not outputting at all when the component is not enabled. This is the case for the Bit Switch component.

[img]dialogue/bit_switch.png[/img]

This means that more than 1 of these grey output pins can connect to the same wire and not cause an error, as long as only one of them is enabled at a time.
$42793594302151* Using 2 NOT gates and 2 Switches, build an XOR gate.


=== trans/instructions_header ===

$15089281203426* [center]Instructions[/center]


=== levels/Calculations ===

$13013863429580* For this level an extra pin has been added to the registers. This pin always emits the value of the register, regardless if load is selected or not.


=== levels/Counter ===

$17940006660359* Count
$17263901743088*
Build a counter that will increase by 1 each tick.

Additionally, there should be an option for overwriting the counter with a given value.

You are given 2 inputs, a bit and a byte.

The bit input should toggle between counting and overwriting with the value of the byte.
$10555159894041*
Counting is so fundamental even insects do it. From counting, species can evolve to compare and do arithmetic. And before you know it, you have apes building computers.

Make a device that counts increments once per tick.


=== trans/manual_text_ram ===

$10969790213397*
This simulator has several types of RAM different trade-offs, similar to real life RAM options.

[b]RAM[/b]
The RAM component can store a lot of data, but adds a very high delay to the circuit.

[b]Fast RAM[/b]
The fast RAM has a low delay, but a very high gate cost per byte.

[b]Latency RAM[/b]
The normal RAM has very high delay, however instead of waiting for this delay each tick, we can treat the RAM as if load and save takes multiple ticks. The number of ticks save and load will take depends on the length of each tick. Say for example that our circuit has a delay of 100 units, a load would take 10 ticks, since we have to wait about 1000 units of delay. 

A common approach for pipelined architectures is to use Latency RAM as for main memory, but use a small amount of Fast RAM for caching. Since memory access is often adjacent or close (for example when looping over an array), fetching adjacent values when loading from Latency RAM and caching them in Fast RAM can significantly speed up certain kinds of programs.

The simplest way to integrate the Latency RAM is simply to stall the whole architecture while waiting for a save or load. An easy optimization on this comes from realizing that you don't have to wait for saves, except if you want to load.

[b]Dual Load RAM[/b]
Sometimes it is beneficial to separate parts of the logic into a separate processing unit, that operates more or less independently. This could be for handling a display device or a network connection. In these cases, the independent unit will often need to continuously load and save to memory, while the outside logic only needs to occasionally load. Use Dual Laod RAM to avoid having to schedule who gets access to the RAM at what time.


=== trans/manual_side_the_robot ===

$56547245144983*
[color=#e49f44][b][/b][/color] The robot sees one 
  tile ahead. The name
  and ID are shown up 
  here. This ID number
  is also the computer's 
  input.


=== components/Rol64 ===

$49017662473189* Rotates the bits of an input left
$13677051385046* Rotate left


=== trans/level_decoder_1_RichTextLabel2 ===

$50454539040073*
[right][color=#e49f44]Input[/color]
Output 1
Output 2[/right]


=== levels/byte_shift ===

$16023356915123* The task in this level is to shift the first input to the left by the value given in the second input. The second input will never exceed 7.
$37338672894296* Shift the bits of {value} left by {amount}
$10598344098990* [center]Shift the first input left by the number of places given by the second[/center]
$16216408139965*
To [color=#e49f44]shift[/color] a value 1 left just means moving all the bits in a byte to the left by 1 position.
For example: [color=#e49f44]90 shl 1[/color]

[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] would become:
[ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] [OFF]

Shifting by 3: [color=#e49f44]90 shl 3[/color]
[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] would become:
[ON] [ON] [OFF] [ON] [OFF] [OFF] [OFF] [OFF]
$18137790657923* In addition to giving you a shift left component, we also had the intern create a shift right component. All he had to do was to create the mirror version of this schematic.


=== components/AND ===

$58912167455465* AND


=== trans/manual_text_ascii_encoding ===

$57727768059917* This simulator uses (extended) ASCII in a few places. Below are the characters with their corresponding number. The console supports different versions of extended ASCII.


=== trans/manual_text_short_circuit ===

$31105471890701*
In electronics, two components outputting different values on the same wire causes a short circuit.

[center][img=100]res://dialogue/short_circuit.png[/img][/center]

However, by disconnecting output pins from a wire, it is possible for multiple pins to share the same wire (called a bus). Importantly, at most 1 component output should remain connected each tick, otherwise you risk a short circuit.

[center][img]res://dialogue/switch.png[/img][/center]

In this simulator, pins that can be disconnected are grey.


=== trans/level_complete_level_map ===

$20801641140962*
[b]Level map mode[/b]
[color=#cccccc][i]Click "[color=#e49f44]Onwards[/color]" and you will see[/i][/color]


=== levels/decoder ===

$18435544383511* CALCULATE pattern\n[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$18945946395447*
To distinguish between the [INSTRUCTIONS] of 4 different kinds, the two highest bits will be used to determine which MODE we are in as follows:
[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Immediate
[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Calculate
[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Copy
[ON] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Condition

Here [ANY] means any value.

Determine the MODE we are in from the input, then send [ON] to the correct output.
$15105859227432* COPY pattern\n[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12068329066372* [b]ALERT: THIS IS AN OUTDATED VERSION OF THIS MAP, PLEASE CLICK THE SAVE ICON IN THE TOP LEFT AND CREATE AND LOAD A NEW SCHEMATIC[/b]
$11382827588408* CONDITION pattern\n[ON] [ON] [OFF] [OFF] [OFF] [ANY] [ANY] [ANY]
$12976424717611* IMMEDIATE pattern\n[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12532951884542* IMMEDIATE


=== levels/bit_inverter ===

$15272914096446* This level is exactly the same as the XOR one you solved before. Remember no matter what we tell you the goal of the level is, the real truth is in the truth table.
$14944872827527* Despite the funny background you figured out this was just the XOR gate in disguise! Well done.
$13224963076378* We are experimenting with how backgrounds influence cognitive functions in earthlings.


=== levels/ram_block ===

$12901484249817* Can you fit 4 bytes of memory in this limited space?
$14218335256117*
In our advanced civilization, forcing prisoners to do extremely menial tasks is slavery and is technically illegal.
	  That is why we instead had our intern create the 256 byte version of your component.
$16196915566111* 0
$14259545926196* A
$12933801309767* A


=== components/Shr64 ===

$93124177265670* Shifts the bits of an input right
$73798355428095* Shift right


=== trans/options_confirm_reset ===

$55371048386984* Right


=== trans/level_compute_xor_description ===

$61886892927185* [center]Pairwise AND together each bit[/center]


=== trans/level_signed_negator_description ===

$87777776285772* [center]Invert the sign of the number[/center]


=== component_panels/LatencyRam ===

$87788654491792*
This kind of RAM would add 1024 delay to the circuit, but instead of extending the duration of ticks, we simply don't wait for the output.

Practically this means that [color=#e49f44]reading takes {ticks} ticks[/color] (since your circuit has {delay} delay).


=== main_scripts/overture_level ===

$11338791453100* Dynamic

#  "cond" is for condition, this label has to be short as it has to fit on a component
$94982725578534* COND
$16914143080303* Copy
$59042824277105* Immediate
$82949244692745* Calculate


=== levels/Further Delayed Lines ===

$60989431641221*
This level introduces the Delay Line component. It takes its input and outputs it 1 tick later.

[img]dialogue/delay_buffer.png[/img]


=== levels/negative_numbers ===

$11067230116844* {number} is not representable
$62744038163781* OK
$19118970740682*
[color=#dd6576]Edit the numbers[/color] for each bit so that the following is true:

[color=#e49f44]1[/color]: All numbers from -127 to 127 should also be representable
[color=#e49f44]2[/color]: Bytes representing anything from 0 to 127 should be the same as unsigned
[color=#e49f44]3[/color]: The new number system should work with the adder (for results between -127 and 127).
$15431436023571* You have two ways to represent 0\nWhich leads to 0 + 1 = 0
$28284583096369* 1 plus -1 does not equal 0\n  
$57604042654667* {number} is not representable


=== levels/robot_race ===

$15403032472607* Robot racing is the favorite sport on the spaceship. Differently programmed robots complete an obstacle course. Among the robots that complete the course, the winner is the one who had the smallest program.
$19966247197959* This time you are controlling Fastbot, he doesn't see what is in front of him, but he can turn to a new direction and move in the same tick. Also he wears fancy red running shoes.


=== components/DelayLine8 ===

$24840584785792* Outputs this tick's input, next tick
$63449911993783* 8 Bit Delay Line


=== trans/manual_console ===

$73523750891893* Console


=== trans/tooltip_tooltip ===

$48829429502039*
[b]Run fast[/b]
[color=#cccccc][i]Run your computer without updating the UI at each tick[/i][/color]


=== components/Screen ===

$12771040946773* Displays the visuals that accompany certain levels
$50037736094411* Screen


=== components/Bidirectional8 ===

$20234315861487* 8 bit bidirectional pin
$49499540884410* Can circumvent certain circular dependency errors


=== components/Shr16 ===

$20291717268875* Shifts the bits of an input right
$31674686871821* Shift right


=== levels/Calibrating Laser Cannons ===

$15260627694444* In order to calibrate said laser, we want you to calculate the circumference of the asteroids using an advanced equation.
$12669851602178* [center]Calculate the circumference of the asteroids[/center]
$16954408093587* On our ship we naturally shoot incoming asteroids with lasers.


=== trans/options_reset_warning ===

$19141523477461*
This will delete all level solutions, custom components and architectures. This can not be undone, are you sure you want to do it?
(This will close the game, it will be reset once you start it again.)


=== trans/map_keys_to_pan ===

$26276191141664* Use keyboard to pan


=== components/NOR ===

$83375115196253* NOR


=== levels/hex_racer ===

$33474352861351* Level {x}
$92057009138253* What is {number} in binary?
$16009852370452*
When dealing with a lot of bits, binary can become hard to read. Hexadecimal (base 16) represents each combination of 4 bits as its own character:
[code]
0 [OFF][OFF][OFF][OFF]
1 [OFF][OFF][OFF][ON]
2 [OFF][OFF][ON][OFF]
3 [OFF][OFF][ON][ON]
4 [OFF][ON][OFF][OFF]
5 [OFF][ON][OFF][ON]
6 [OFF][ON][ON][OFF]
7 [OFF][ON][ON][ON]
8 [ON][OFF][OFF][OFF]
9 [ON][OFF][OFF][ON]
A [ON][OFF][ON][OFF]
B [ON][OFF][ON][ON]
C [ON][ON][OFF][OFF]
D [ON][ON][OFF][ON]
E [ON][ON][ON][OFF]
F [ON][ON][ON][ON]
[/code]

As an example where hexadecimal is much clearer, lets compare the representation of the largest 16 bit number:
[code]
Binary:      1111111111111111
Decimal:     65535
Hexadecimal: FFFF
[/code]

It is not easy to tell if the binary is missing a digit or if the decimal number is off by 1, the hexadecimal on the other hand is immediately clear (once you get used to the representation at least).
$40775762006843* Wrong answer
$84691609525475* This level is my second favorite pastime. Converting hexadecimal to binary under time pressure.
$45532697833519* You made it to level {level}!
$87016829502381* Good job, you reached level {current_level}.
$43463538043782*
Toggle the bits in the level panel so they add up to the hexadecimal number in the question.

You must beat level 3 to pass.

(click [color=#e63e5b][url=accessibility_mode]here[/url][/color] to turn on timerless accessibility mode)


=== trans/manual_send_otuput_robot ===

$65542429897149* [center]Send output to control the robot[/center]


=== components/Ror8 ===

$10802217509530* Rotates the bits of an input right
$70999134800536* Rotate right


=== components/NAND ===

$71130919681688* NAND


=== levels/Water World ===

$13739681561355* Total volume: 
$19185457941725* Good news, we want to turn earth into an exotic water park!
$18940654086036* We need you to help us find a good location for the Pirate's Plunge waterslide. Specifically, we are looking for an area that can hold a high volume of water.
$14706805272652* Hit ENTER to show water
$12881972193444*
The landscape is 16 columns wide. Read the input 16 times to get the height of the landscape at each column from left to right.
	
Then output the total volume that the landscape can carry as the answer.


=== levels/delay_level_check ===

$59355217078543* Correct!
$68999077595244* Check
$90847326020954* Nope!


=== levels/Dancing Machine ===

$14975070588197*
We all like the way Robot moves on the dance floor. That's why we want him to lead our dance team. 
	
The only problem is to make him come up with original dance sequences. How do you make creativity out of deterministic logic you ask?

The answer pseudo random number generators.


=== trans/level_binary_programming_description ===

$66247694103179* [center]Add 5 to the input[/center]


=== trans/level_component_factory_Label2 ===

$37347658035959* Component preview


=== levels/Add 5 ===

$11540713506719*
You are now free to change the program of your computer.
Click the edit icon on the program component to start programming.
$19281970848639* [center]Add 5 to the input.[/center]
$17770257567603* So in the meantime we will have you help out on the ship a little.
$19446152707984* Click on the edit memory icon on the program component to start programming your computer. Your computer should read an input, add 5 to it and output it again (no need to worry about overflow).
$80639633676917* Input:
$12078933051174* But since you don't know how to program it yet, you are not quite ready for that.
$11074247151096* Notice that the immutable red register components have been replaced with a custom component with identical functionality.
$18134632592542* You have built your computer, but to win the competition you still have to finish the maze.


=== components/Output16z ===

$78873885833823* Switched Output
$54278394672948* Only outputs if the switch pin is [ON]


=== main_scripts/levels ===

$64510812504271*
Some of the components used are not supposed to be available in this level!
The solution is not scored.

#  Level type for the level complete menu
$58769207148712* Component

#  Level type for the level complete menu
$90134890578411* Misc

#  Level type for the level complete menu
$69219742310717* Architecture


=== misc/program_edit_signals ===

$98772447663910* Link components


=== trans/manual_short_circuit ===

$41209541005460* Short circuit


=== trans/manual_text_turing_complete ===

$54897112350567*
Certain computers, like simple calculators are limited in the algorithms they can perform.

They cannot perform any calculation that requires looping or recursing an arbitrary amount of times. Technically machines without looping or recursion can only deal with combinational logic.

Turing complete machines on the other hand are as powerful as it is possible to be. A Turing complete machine may have a slow CPU, but it is powerful in the sense that there is no (computable) algorithm it can't perform.


=== trans/level_complete_ide ===

$56719825235196*
[b]CODE IDE[/b]
[color=#cccccc][i]Name codes and edit them in a convenient editor[/i][/color]


=== levels/byte_mux ===

$49305362057225* Your answer {your_answer}\nCorrect answer {correct_answer} (Input {input})
$18296416014178* When the bit selector input is [OFF], output Byte A, otherwise output Byte B.
$17093993196554*
Even though he did not pass our tests we decided to keep the dog. Unlike most earthlings he is fluffy and follows simple instructions well. 

We might want to team you two up, since you compliment each other's shortcomings well.


=== trans/level_byte_constant_description ===

$84789919073603* [center]Always output the number 164[/center]


=== trans/level_alu2_code ===

$93157894815498* [center]OR[/center]


=== misc/binary_submit ===

$95509904060545* Submit


=== components/Output8z ===

$16915419621070* Switched Output
$58449766432492* Only outputs if the switch pin is [ON]


=== components/Maker16 ===

$39941195789458* 16 bit Maker


=== trans/level_decoder_description ===

$10169248860836* [center]Decode the instruction[/center]


=== trans/options_disagree ===

$60077370372179* Disagree


=== nim/backend ===

$98703677236827* 1 minute ago
$86244493049244* {hours} hours ago
$95018143828198* 1 year ago
$21685594109067* Just now
$98363990684104* 1 hour ago
$84076931764831* 1 day ago
$18300496139706* 1 month ago
$17901039729248* {months} months ago
$42553566189409* {minutes} minutes ago
$70945526841433* {years} years ago
$14036822471924* {days} days ago


=== trans/instructions_hint ===

$65105856275770* [center][color=#c5c5c5]Click to toggle the bits[/color][/center]


=== levels/sandbox ===

$17054292175058* Welcome to the sandbox, here you are free to play around. I have given you 64 bit wires and a few IO components.
$10731996208080* There are also 64 bit versions of the program, the counter, the register and the ram. Notice though, the 64 bit ram takes 1 tick to load.
$14434122873489* The Waveform Generator lets you make sounds. I will probably regret giving you this one.
$18405942066048* The Clock gives you the current UNIX time in microseconds.
$10451578314373* The Console Screen lets you draw characters to a screen (see manual for ascii characters)


=== components/Output64z ===

$61656790122480* Switched Output
$42506906257154* Only outputs if the switch pin is [ON]


=== components/NOT ===

$34453052824732* NOT


=== components/DivMod32 ===

$61314390474120* Divide and mod 2 numbers
$84309999871615* Divide


=== trans/level_registers_code ===

$40063003736243* [center]OR[/center]


=== trans/manual_text_truth ===

$16559670174521*
The tables of input and output which are used everywhere throughout the game are commonly known as truth tables.








"Input" and "Output" will often be represented with variable names, like in algebra. And instead of using colors, you will often see the values represented as 0 / 1 or False / True.


=== trans/manual_text_terminology ===

$99266452352883*
[b]Instruction[/b]
A byte or a few bytes that together make the computer perform a specific action.

[b]Opcode[/b]
The part of the instruction that determines which operation (like ADD or AND) is to be done.

[b]Memory address[/b]
A number used as a name for memory locations (often for registers). These are used to specify where an instruction is supposed to load data from or save data to.

[b]Jump[/b]
Changing the value of the program counter, changing which instruction is loaded next.


=== levels/Conditionals ===

$18542005958715* Set the counter increment to 4
$17133561664335* Congratulations, you finished the [color=#e49f44]LEG[/color] computer!
$12920514303805* Add 6 registers to the map
$14309211963063* Create a new schematic and add a program with 4 byte output
$30132649789584* Linked component {number} should point to the output
$18994998239232* I will show you some upgrades you can make, on the path to implementing function calls. But from here on the details are up to you, I wont tell you what opcodes to use and so on.
$12034111753799* Linked component {number} should point to the counter
$36561706158040* Linked component {nr} should point to a register or custom component with a register inside


=== trans/level_complete_hex ===

$94261690850981*
[b]Hexadecimal[/b]
[color=#cccccc][i]Toggle between signed, unsigned and hex numbers[/i][/color]


=== levels/byte_less ===

$11632471752785* [center]Determine if the first input is less than the second.[/center]


=== levels/Logic Engine ===

$17594613477534*
Create a device that can OR, NAND, NOR or AND two inputs. The third input will be the [INSTRUCTION]. An [INSTRUCTION] is just what we call the number that determines what to compute.

Instructions:
[code][color=#87a8c8]0 OR
1 NAND
2 NOR
3 AND[/color][/code]

Also you can't move the red components in this level, for reasons that will be revealed later.


=== trans/level_the_bus_description ===

$20464862486158* [center]Copy the value from the correct input, to the correct output[/center]


=== trans/level_byte_less_i_description ===

$21195810950441* [center]Determine if the first input is less than the second.[/center]


=== trans/instrucitons_header ===

$14831276667273* [center]Instructions[/center]


=== levels/byte_or ===

$10368115829346* But actually it is OK because you lived good lives in the wild and we don't let the meat go to waste.


=== trans/level_complete_gate ===

$99373213759665*
[b]Gate score[/b]
[color=#cccccc][i]You can now view the gate score of  wires and components.[/i][/color]


=== trans/manual_text_universal_gates ===

$37735744928195*
It turns out that you can build all the logic for a computer out of either NAND or NOR gates. The Apollo guidance computers, were built entirely of NOR gates. Designed in the sixties, they had only 4KB of RAM and 32KB of disk space, but guided astronauts to the moon nonetheless.

Modern computers are not built entirely of just one of the universal gates, but when applicable NAND gates are preferred over NOR, because they have less delay and occupy less area.


=== components/Bidirectional64 ===

$82412839066570* 64 bit bidirectional pin
$24932613021646* Can circumvent certain circular dependency errors


=== trans/level_complete_profile ===

$78783902500954*
[b]Online profile[/b]
[color=#cccccc][i]Find it in the main menu.[/i][/color]


=== components/SRLatch ===

$11641785582600* Set/Reset Latch
$71931050184389* [img=165]dialogue/sr_latch_tooltip.png[/img]


=== trans/levels_byte_or_description ===

$68379799788575* [center]Pairwise OR together each bit[/center]


=== misc/skipped_custom ===

$38174137226538* Select component

#  This is the text on a button that appears when a custom component has changed size and no longer fits in a schematic. You can press this button to make the camera go to the location where the custom component was
$99860977387728* Go to location


=== misc/add_code_name ===

$57358078712675* Save


=== levels/Spacial Invasion ===

$19967210826470* Be aware that the laser can only shoot when there are no other laser beams already in flight.
$16294185981398* The cargo hull has become infested with space rats.
$11505369795084* Check [color=#e49f44][url=the_robot]robot page[/url][/color] for instructions on how to program him. There is a link to that page in the program editor as well.
$10515630949378* We have hooked your machine up to our advanced robot and we want you to program it to shoot the space rats with lasers.


=== components/Nand8 ===

$50859914201083* Bitwise NAND two values
$93314093190526* 8 Bit NAND


=== trans/map_available ===

$81707212583931* Available


=== trans/manual_text_negative_numbers ===

$85226853816564*
The way to represent negative numbers you discovered is called "two's complement". It is the standard way to represent negative numbers in modern computers. The main advantage of two's complement is that the negative representation works seamlessly with the same adder that we used for the non signed representation.

In the early days of computing, the main contender to two's complement was one's complement. Its main advantage is that changing the sign of a number is simple, you just NOT each bit in the number. However, it has 2 representations for 0, a positive and a negative, which makes comparisons more difficult.

Another interesting representation, perhaps worth looking up is base -2, where the sign of the value of each digit alternates between positive and negative.


=== components/Add64 ===

$14174811828377* Adds two inputs
$73418471595285* Add


=== trans/options_console ===

$96601731563408* Open console


=== components/DivMod64 ===

$80284847781948* Divide
$71663353206665* Divide and mod 2 numbers


=== levels/saving_bytes ===

$13502950630653*
[color=#ff9800]None
0
0[/color]
$19109563882664* DON'T LOAD
$16372198430230* SAVE
$15498440508450* Do nothing
$15582618410991* LOAD and SAVE
$18873598212433* LOAD


=== trans/ide_add_assembly_header ===

$94462268558066* [center]Add assembly code[/center]


=== components/Output 1 + 1B ===

$43917122084061* Accepts output for levels
$81929942356043* Level output


=== main_scripts/leg_level ===

$85913831661289* IF_LESS
$69956969985790* ORi
$53021804895845* ANDi
$11144256835662* XORi
$61412773713567* SUB
$20104629254326* ARGUMENT 2
$65642901654732* {component} should be disabled
$52344899983501* IF_LESS_OR_EQUAL
$89945092889418* SUBi
$89011349770597* NOT
$71559031724238* IF_NOT_EQUAL
$98778676892898* {component} should be enabled with value {value
$40520283279584* XOR
$71204580217527* NOTi
$71195301111400* ADDi
$98178474649432* IF_GREATER_OR_EQUAL
$68187490877029* IF_EQUAL
$14186606871089* Next tick counter value will be {wrong_value}, but it should be {value}
$27868897434461* Could not find the counter component
$37810243909140* COUNTER
$44009845985661* ADD
$38681417496680* ARGUMENT 1
$68666991962246* OR
$24003300271049* {component} should have value {value}, not {wrong_value}
$79492115258673* IF_GREATER
$60997201855346* RESULT ADDRESS
$50231510806554* Could not find the program component
$64519909700148* AND
$49810487048038* COUNTER
$84307766381146* OPCODE


=== levels/call_ret ===

$15840165316981*
In this level you are tasked with implementing function calls and returns with the [color=#e49f44]call[/color] and [color=#e49f44]ret[/color] instructions.

Note that when returning from a function, you should jump to the address that came AFTER the [color=#e49f44]call[/color] instruction, otherwise you will end with an infinite loop.
The [color=#e49f44]call[/color] instruction has to do the following:
 [i]- Add the instruction width to the counter value and [color=#e49f44]push[/color] it on the stack[/i]
 [i]- Jump to the function address[/i]

The [color=#e49f44]ret[/color] instruction has to do the following:
 [i]- [color=#e49f44]Pop[/color] return address from the stack and jump to it[/i]

You can pass information to and from a function by saving the data to registers as normal. Also be aware of which registers a function will overwrite before calling it.
$19369640789869* Budget cuts have led to cutting salaries, but now the lab assistants are on strike. You will have to self-assess in this test. This will tell us something about your honesty and maturity.


=== misc/ProbeWireBit ===

$49521764791439* Wire Probe (bit)
$15206117280094* Display a value on your custom component or in the program editor


=== trans/manual_computer_concepts ===

$60892983318818* Computer concepts


=== misc/solution_option ===

$21618236951146* View solution


=== components/ByteShr ===

$89595863403484* Shift right
$69394421220436* Shifts the bits of an input right


=== trans/level_complete_delay ===

$73470840319057*
[b]Delay[/b]
[color=#cccccc][i]You can now view the delay of wires and components.[/i][/color]


=== components/LessU64 ===

$13018528868948* Less (unsigned)
$90244529484227* Checks if one input is less than the other


=== levels/divide ===

$76454016047920* {numerator}/{denominator} = {quotient}, remainder {remainder}


=== components/Nor64 ===

$17208777467974* Bitwise NOR two values
$72509242083648* 64 Bit NOR


=== trans/level_byte_no_description ===

$19806403089477* [center]Invert each bit[/center]


=== trans/manual_RGB_color ===

$62337044104456* RGB color


=== misc/instruction_expand ===

$44690074039467* Toggle define rules


=== trans/manual_text_instructions ===

$24791538034329*
What this game calls an "instructions" is also known as an operation or an opcode (short for operation code). Regardless of the operating system, programming language or any other layers above it, all software must inevitably be reduced to instructions for the CPU to process them.

Internally in modern CPUs, instructions are translated into "microcodes", which are even smaller steps, out of reach for the programmer.


=== components/Xor32 ===

$66299093873977* 32 bit XOR
$38169019785615* Bitwise XOR two values


=== levels/Delicious Order ===

$10160261151833* First read the 15 deliciousness scores from the input one by one. Your task is to output them in sorted order, smallest to largest.
$16027225087666* We are updating the galactic encyclopedia of food, inserting human foods. As we don't have an alphabet, entries in the encyclopedia are ordered by deliciousness.


=== components/Equal64 ===

$34603983706314* Checks if the two inputs are equal
$82876546747608* Equal


=== trans/level_byte_adder_you_carry_text3 ===

$65048723622767* Number


=== components/IndexByte ===

$27264669944539* Byte Indexer
$54699455184164* Extracts a byte from a wire


=== trans/manual_text_circular_dependency ===

$29050562435902*
A circular dependency is when the input of a component changes based on its own output. 

[center][img]res://dialogue/circular_dependency.png[/img][/center]

This simulator does not allow circular dependencies and instead triggers an error. 

The exception to this are the square pins that do not influence the output in the same tick. They can therefore not cause circular dependencies.

[center][img]res://dialogue/delay_buffer.png[/img][/center]


=== components/LessU16 ===

$91783087669146* Checks if one input is less than the other
$33190791348214* Less (unsigned)


=== trans/level_nand_check ===

$32982011047799* Check


=== trans/level_complete_tooltip ===

$33922330743421*
[b]Wire color[/b]
[color=#cccccc][i]Keep your wires organized with colors.[/i][/color]


=== trans/level_turing_complete_description ===

$74859324795927* [center]Add conditions to the calculation codes[/center]


=== components/Bidirectional16 ===

$31038378395810* 16 bit bidirectional pin
$99604485981015* Can circumvent certain circular dependency errors


=== trans/manual_component_factory ===

$35460636622618* Component factory


=== trans/level_tick_tock_description ===

$34658332565777* [center]Add 1 to the counter, or overwrite it[/center]


=== levels/push_pop ===

$78804623186243* OUTPUT
$49526452710191* DON'T POP
$58050047963238* VALUE
$19245209470436* Create a stack
$15662660252584* Do nothing
$62469306234943* DON'T PUSH
$65188797398656* PUSH {value} on stack
$18761197388580* In order to cut spending, it has been decided to change the queuing system at public offices so that fewer people will go. Instead of first come, first served, we are implementing a last come first served policy. Think of it like a [color=#e49f44]stack[/color] of numbered slips where the citizens either put a slip on top (called [color=#e49f44]PUSH[/color]), or the bureaucrats take one off the top of the stack (called [color=#e49f44]POP[/color]). We want you to implement this new system.
$46948857059388* POP value {value} off stack


=== levels/Tower of Radioactive Alloy ===

$13757925963562* Specifically we want you to move piles of radioactive disks from an old reactor. Just be sure not to put a bigger disk on top of a smaller disk or the whole ship will blow up.
$10750976989948*
The first 4 inputs will give you the following in order:
disk_nr - The highest disk number in the pile (2 to 4)
source - Which location number to move from
destination - Where to move the pile to
spare - The 3rd spot that is neither the source nor the destination

Control the crane with the following outputs:
0 - Move the magnet to spot 0
1 - Move the magnet to spot 1
2 - Move the magnet to spot 2
5 - Toggle the magnet on or off

Play with the magnet manually by using the arrow keys to move and enter to toggle.
$19265994465686* We need you to help clean up the basement.
$35120623183961* Move from {source} to {destination}
$15855497886737*
Implement the following algorithm:

Tower of Hanoi algorithm:[code][color=#87a8c8]
func move(disk_nr, source, dest, spare):
	if disk_nr is 0:
		move disk from source to dest
	else:
		move(disk_nr - 1, source, spare, dest)
		move disk from source to dest
		move(disk_nr - 1, spare, dest, source)

move(disk_nr, source, dest, spare)[/color][/code]

[tip]Push register values to the stack to save them before calling a function that changes them.[/tip]


=== trans/level_complete_robot ===

$73150174144736*
[b]Robotron 9000+[/b]
[color=#cccccc][i]Control [color=#e49f44]Robotron 9000+[/color] using your computer[/i][/color]


=== levels/The Product of Nibbles ===

$14957949958941* What you did here was actually multiplying two 4 bit numbers. We had the intern scale it up to bytes instead.
$19136817138607* [center]Multiply the 4 bit numbers[/center]
$13549246864135* Bit 0
$10274387271390* Bit 0
$83694551809785* Multiply {num1} and {num2}


=== trans/manual_universal_gates ===

$28345532918560* Universal gates


=== trans/wire_comment ===

$41481492318983* Wire comment
$87836369268219* Save
$34083666001769* Wire comment


=== components/LessI64 ===

$42718501644862* Less (signed)
$19948786194409* Checks if one input is less than the other


=== components/ByteLessU ===

$68645721548287* Checks if one input is less than the other
$73502755965496* Less (unsigned)


=== main_scripts/functions ===

$73560327420927* This save is from an obsolete version of this level.\nCreate and load a new schematic in the schematic menu.
$99285446909923* To solve this level you need to use the 'Level output' component
$72465734060414* Short circuit on wire (output values: {values})
$10533010562232* DELAY SCORE: {delay}
$10098517717617* Test: {nr} / {total}
$29225283986051* To solve this level you need to use the 'Level input' component
$87591753278764* Reg {nr}
$95056157627313* To solve this level you need to use the 'Level input' component
$12249248261034* To solve this level you need to use the 'Level output' component


=== ui/global_translations ===


#  Instead of writing 5839000, the number turns into 5.8M
$22896492410578* M

#  Instead of writing 5839, the number turns into 5.8K
$84696693690500* K

#  Instead of writing 5839000000, the number turns into 5.8B
$71072134093858* B


=== trans/manual_text_binary ===

$69488982380310*
The numbers you are used to are base 10, here when we add a 0 to the right hand side of a number, it's value increases 10 fold.

Binary is base 2, so doing the same will instead just double it. In other words, each digit represents a power of 2. For example with [color=#c54d5e]base 2[/color] and [color=#e49f44]base 10[/color] color coded:
[color=#c54d5e]    1[/color] = [color=#e49f44]1[/color]
[color=#c54d5e]  10[/color] = [color=#e49f44]2[/color]
[color=#c54d5e]100[/color] = [color=#e49f44]4[/color]

To represent 6 we can simply add 4 and 2:
[color=#c54d5e]110[/color] = [color=#e49f44]6[/color]

Addition, multiplication and everything else works the same as base 10, except you carry when you reach 2 instead of 10.


=== trans/level_alu1_description ===

$90245779080897*
[center]OR, NAND, NOR or AND
the two bytes together[/center]


=== trans/map_complete ===

$81337533438394* Complete


=== components/Program1Red ===

$26811947547688* Programmable memory component
$55594749714809* Program


=== components/Shl16 ===

$79406691850426* Shift left
$34287811246049* Shifts the bits of an input left


=== levels/or_gate_3 ===

$15448906128695* Create an OR gate with 3 inputs.


=== trans/binary_racer_count_down2 ===

$23959994711260* Ready to race?


=== trans/schematics_menu_visible_label ===

$34084132835354* Visible in menu


=== components/RegisterRedPlus ===

$57531353625235* Register


=== trans/level_description ===

$26184794529449* [center]Add conditions to the calculation codes[/center]


=== components/Counter64 ===

$62528867413395* 64 Bit Counter
$62736827510023* Increments each tick, unless overwritten


=== levels/Storage cracker ===

$11910674853271*
The security access door to the storage room is broken and it keeps locking our old janitor inside.

The door keeps changing the passcode, we need a program that can recover the passcode at any time.
$17462419719036*
The easiest way to find the passcode would be to try all combinations until you find the right one. 
Although the broken mechanism does make a weird beep when your guess is too high, you might be able to use that to your advantage.
$11183892008673* You win this level when you output the correct passcode, no output will fail the level. Additionally, the input will be 1 after a guess that was too high and 0 otherwise.


=== levels/constants ===

$17098439090371*
We need a way to directly move numbers from our program into registers. For this we use the immediate mode (when the two highest bits are [OFF][OFF]).

When in immediate mode the whole byte is interpreted as a number that we [SAVE] into REG 0. This means we can 
[SAVE] any value between 0 and 63.


=== trans/ide_binary_header ===

$22615032668969* Binary Editor


=== trans/level_registers_text ===

$78241632854567*
[right][color=#e49f44]Code
Input[/color][/right]


=== levels/program ===

$16693098943939*
The [INSTRUCTION] input component has been removed. It has been replaced by a program component. Every tick, use the counter to load the next [INSTRUCTION] from the program's memory.
	
You must use the counter component you unlocked earlier for this level.
$19686277478479* The program is still outputting the first instruction. Did you hook up a counter?


=== components/Ror64 ===

$43920264894591* Rotate right
$49583010717958* Rotates the bits of an input right


=== trans/manual_text_program ===

$25326551844839*
The program component is a read only memory component, that can have its data programmed in assembly. To edit the assembly, click on the yellow edit icon in the corner of the component.

[center][img]dialogue/manual/program_edit.png[/img][/center]

In the middle of the screen you will see the code area, read more about the assembly [color=#4d82c5][url=Assembly]here[/url][/color].

On the left hand side of the assembly editor interface, you can add assembly codes (mnemonics). Assembly codes act as a replacement for numbers, so instead of remembering what number represents the AND instruction in your architecture, you can add "AND" to your assembly codes, making code easier to read and write.

[center][img]dialogue/manual/assembly_codes.png[/img][/center]

On the program component you will also find the "Watch state" button. 

[center][img]dialogue/manual/watch_state.png[/img][/center]

This can be used to connect the assembly editor to registers, counters or probes. This way, the state of your architecture can be inspected as you write code, without closing the editor.


=== trans/manual_components ===

$40288888375581* Components


=== levels/capitalize ===

$14894954428144*
The inputs in this level represent the characters in a list of planet names, encoded as ASCII (see the manual). Each name is separated by a space which has the numeric value 32. Replace the first letter in each word with its uppercase counterpart.
(The possible input characters are a to z lowercase, space, apostrophe and dash)
$13301617098810* We had the intern type out planet names in human script. Unfortunately he forgot to capitalize each name.
$11647445869837* Input: 
$11201813578269* Output: 


=== levels/byte_equal ===

$17156565273196* Output [ON] when both inputs are the same.


=== components/Output32z ===

$73681609562628* Only outputs if the switch pin is [ON]
$92749186427039* Switched Output


=== trans/level_program_text ===

$38014836341470*
[right][color=#e49f44]Code
Input[/color][/right]


=== trans/level_complete_stat_time ===

$39203727515285* Time


=== components/Rol8 ===

$79612280948390* Rotate left
$55557725551789* Rotates the bits of an input left


=== components/OR ===

$97247779246257* OR


=== trans/manual_text_matrix ===

$75170402412137*
[b]Showing letters[/b]
It just so happens that a pixel space of 5x7 while small is still able to render letters nicely. By adding an extra row and column, these letters will also look nice when put next to each other. 

[center][img]dialogue/manual/matrix_letter.png[/img][/center]


[b]Small tileable screen[/b]
Rotating the component, you get 8x6 pixels, which has a nice 4:3 aspect ratio and tiling these, you can get most resolutions you might want. The way the pins are set up on this component was specifically designed to allow tiling. Imagine the naive pin design where each component is enabled by a single bit. This would require you to connect 1 wire for each component. In this situation, the number of wires needed for a tiled screen would scale with the area, while the gap needed to fit wires between components, would scale with the circumference. 

[center][img]dialogue/manual/tilable_screen.png[/img][/center]

Instead, by having 2 enable pins, one wire can enable a whole row and another a whole column. This way, a single component can be selected by its unique row and column combination. Further, fitting the rest of the data on the same wires, means that the horizontal and vertical gaps only need to be 1 square wide. This component visually takes up half a square extra on all sides, such that these components can be tiled up pixel perfectly, with 1 square hidden between them for running wires.


=== trans/level_byte_equal_description ===

$38686097566531* [center]Check if the bytes are equal[/center]


=== trans/manual_text_top_truth ===

$83283949590490* AND gate


=== components/Clock ===

$72088325385177* Clock


=== components/Xnor ===

$94079327237795* XNOR


=== trans/tick ===

$92150881431937* Tick


=== components/1_decoder ===

$26685462633615* Toggles between two outputs
$98250587600120* 1 Bit decoder


=== components/XOR ===

$54832952840086* XOR


=== trans/levels_double_the_number ===

$41609125516676* [center]Double the number[/center]


=== components/IndexBit ===

$89611629299917* Bit Indexer
$84431924133490* Extracts a single bit from a wire


=== components/Not16 ===

$17394768116288* 16 Bit NOT
$91053300263019* Bitwise negates 16 bits


=== trans/level_complete_manual_page ===

$39011561067359*
[b]Manual Entry[/b]
[color=#cccccc][i]RTFM[/i][/color]

Entry: [color=#68d277]Architectural complexity[/color]


=== trans/level_spacial_invasion_description ===

$44980627299841* [center]Shoot the space rats![/center]


=== trans/manual_network ===

$67416967652082* Network


=== levels/registers ===

$10661964231175* I have locked the red components of this level in place, since you always make a mess and don't leave enough space. The mess you make from now on is saved between levels, you no longer get to start fresh each level.
$10211777161405*
These are the bit patterns for each [color=#c54d5e]source[/color] and [color=#e49f44]destination[/color].

[color=#c54d5e]Source[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  INPUT 
[ON] [ON] [ON]  UNUSED

[color=#e49f44]Destination[/color]:
[OFF] [OFF] [OFF]  REG 0 
[OFF] [OFF] [ON]  REG 1 
[OFF] [ON] [OFF]  REG 2 
[OFF] [ON] [ON]  REG 3 
[ON] [OFF] [OFF]  REG 4 
[ON] [OFF] [ON]  REG 5 
[ON] [ON] [OFF]  OUTPUT
[ON] [ON] [ON]  UNUSED

To get a more intuitive understanding of the requirements, click the [INSTRUCTION] icon in the upper left corner.
$14108238519744* Time to create your master project, implementing the [color=#e49f44]OVERTURE[/color] computer architecture. This will be an actual Turing complete machine, a true computer in every way!
$14411286553593* Finally, the input and output components now have an additional pin. Set that pin [ON] when you want to read from input, or copy to output.
$14041158687959*
[color=#c54d5e]Source[/color] and [color=#e49f44]destination[/color] can be 1 of 6 registers, we will name them REG 0 to REG 5 respectively. 
	
Additionally, this map has a dedicated input component, which can be the [color=#c54d5e]source[/color] and an output component, which can be the [color=#e49f44]destination[/color].


=== misc/factory ===

$53123649343022* Component Factory


=== trans/level_complete_stat_level ===

$92313038380926* Level


=== components/Ror16 ===

$13970397213910* Rotates the bits of an input right
$90115282457191* Rotate right


=== misc/opcode_name ===

$15090156481094* Name


=== components/Nor16 ===

$57921392198825* Bitwise NOR two values
$69522380057631* 16 Bit NOR


=== trans/manual_header ===

$10757271456963* Manual entries


=== components/ON ===

$96212935718484* Always [ON]
$95896157427528* ON


=== trans/options_setting_program_alignment ===

$54874717650167* Program alignment warning


=== misc/level_gate_unlocks_unknown ===

$76731326010721* Unlocks something unknown


=== misc/level_gate_manual_icon ===

$22002156022920* Unlocks manual entry


=== components/DotMatrixDisplay ===

$18651725958642* 6x8 Dot Matrix Display
$71512568789377* 6x8 pixel display


=== components/Ror32 ===

$84788620524361* Rotate right
$50013003040535* Rotates the bits of an input right


=== levels/Masking Time ===

$17375862136921*
The length of our week is 4 days. Our weekdays are named Zero's day, One's day, Two's day and Three's day. I hear some earthlings number their Two's day incorrectly? 
	
It doesn't really surprise me.
$65431688078892*
In this level you are given a number as input and you should return that number modulo 4 as a result.

The challenge is that you only have {ticks_per_test} ticks to output the desired result.

Note, you don't need to change your hardware, you just have to figure out the trick to do modulo 4 quickly.
Use [color=#e63e5b][url=masking_time]this hint[/url][/color] if you get stuck.
$81055582534899* Anyway new year is coming up and we want you to calculate the weekday of everyone's birthday. We will give you the date and all you have to do is return the weekday within {ticks_per_test} ticks.


=== trans/levels_negative_header ===

$82195103144851* [center]Requirements[/center]


=== components/RegisterRed ===

$10081371413873* Register


=== trans/delete_confirm ===

$57294448765637*
Are you sure you want 
to delete this schematic?


=== components/ByteLessI ===

$52765625016236* Checks if one input is less than the other
$25403981009644* Less (signed)


=== levels/byte_adder ===

$16888130664370*
If the result does not fit in 8 bits, turn the output carry [ON] (you can think of it as the 9th bit)
	
Finally, there is an input carry as well. This is useful for chaining together byte adders to add larger numbers. You can think of this carry as adding either 0 [OFF] or 1 [ON].

Use [color=#e63e5b][url=byte_adder]this hint[/url][/color] if you get stuck.
$18732877690173* Add the two input bytes. Each output bit in the output should be a result of the addition of the corresponding bits from the inputs, and potentially a carry.


=== components/Mux32 ===

$16638728645850* Toggles between two values
$21257226547838* 32 Bit Mux


=== components/LessI16 ===

$75600169624828* Less (signed)
$73697238171042* Checks if one input is less than the other


=== components/Shr32 ===

$87104108203785* Shifts the bits of an input right
$88430124157796* Shift right


=== misc/FileInput ===

$28866575833369* Reads bytes from your hard disk
$34159012148766* File Loader


=== components/BitSwitch ===

$56917313833836* Toggles a bit
$41574334638147* Switch


=== trans/level_constants_description ===

$34641396464207* [center]Add constant loading to your architecture[/center]


=== components/DelayLine64 ===

$80000130396288* 64 Bit Delay Line
$35525647389906* Outputs this tick's input, next tick


=== misc/overture_add_assembly ===

$10565133223872* Never
$62421757655527* Name a code and click save.
$24281479096246* When [color=#2b8738]result[/color] {condition}
$63525237058165* Copy from {source} to {destination}
$32873193471770* UNUSED
$88446594314360* Immediate: {number}
$94278717238239* Always
$79398554520691* {opcode} {reg_1} and {reg_2}
$72740868980397* {condition} copy {register} to counter


=== trans/level_unseen_fruit_description ===

$96313037592447* [center]Use the robot to scan the fruit[/center]


=== trans/manual_circular_dependency ===

$40263928358112* Circular dependency


=== trans/manual_Cyclic recipes ===

$45682345144408* Circular recipes


=== main_scripts/dialogue ===


#  Hint for byte switch
$86319296925137* What would this look like if you were only switching 1 bit? What would the truth table for such a component look like?

#  hint for the bus
$50799425816171* Use switches to put the inputs on the same wire.

#  hint for odd number
$68750974209145* You can figure out if 2 inputs have an odd number of [ON] with just 1 component...

#  Hint for the maze
$36837749971886*
Always following the left (or right) hand side of the maze will make sure you eventually reach the exit.
	
The pseudo code for such an algorithm looks like this:
 Step forward
 Turn left
 Turn right as long as there is a wall ahead
 Press use after each turn (in case the exit is ahead)
 Repeat

#  hint for counting signals
$21044442262778* The circuitry for the 1's bit is the same as what you did in the level "Odd Number of Signals". The circuitry for the 2's bit is what you did in "Double Trouble", except when all 4 are on.

#  hint for saving gracefully
$25321701584378*
In this level you need to use 1 Delay Line. Make a truth table for what should go into the Delay Line. Consider the input to the Delay Line as the output for your table. 

The inputs are the 2 level inputs AND the output of the Delay Line, as the output plays a role in its input. In total you have 3 "inputs" to for this table which gives you 8 combinations. Once you have the level requirements as a table, it should be a lot easier to solve.

#  Hint for conditions
$87674181578455*
There are 3 condition bits. The first bit being [ON] means the result being 0 meets the condition. The second bit being [ON] means the result being less than 0 meets the condition. If either of those two are [ON], the condition is met. 
Finally, if the last bit is [ON], negate the status of the condition being met or not.

#  hint for xor gate
$88963098241493* This level can be done with 3 components, a NAND, an AND and an OR gate.

#  Hint for masking time
$46866534894828*
In binary, taking modulo 4 of a number is the same as only using the two lower bits. This is because the higher bits represent 4, 8, 16 etc, and they all divide 4 with no remainder.
This is true in general for modulo a power of 2, the lowest bit of a number represents that number modulo 2 (even or odd), the lowest 3 bits modulo 8 and so on.

Likewise, in decimal 4321 modulo 100 is also simple (answer is 21, the higher digits are disregarded), this is because 100 is a power of 10.

Now you just have to figure out how to get the last 2 digits of a number.

#  hint for less
$56438995128380*
First determine which bits are different between the 2 bytes. This can be done using a byte XOR (remember XOR turns [ON] when the inputs are not the same). We know the number that has the highest different bit [ON] is the larger number. But we must only consider the highest different bit, so for each bit, use a chain of OR gates to check if any higher are [ON].
		
Finally, the last bit is considered separately for signed numbers, here it has the opposite effect (if only one number has it [ON], that number is guaranteed to be lower)


=== trans/instructions_the_robot ===

$26621808961883*
[color=#e49f44]0[/color] Move right
[color=#e49f44]1[/color] Move down
[color=#e49f44]2[/color] Move left
[color=#e49f44]3[/color] Move up
[color=#e49f44]4[/color] Enjoy the moment
[color=#e49f44]5[/color] Use action [color=#a9a9a9](enter)[/color]
[color=#e49f44]6[/color] Shoot laser [color=#a9a9a9](tab)[/color]


=== levels/binary_count_down ===

$56999237564848* {x} seconds left


=== components/Nand32 ===

$24565725389553* Bitwise NAND two values
$71611588991682* 32 Bit NAND


=== trans/level_complete_level_complete ===

$49647690443210* [center]Level Complete[/center]


=== components/Rol32 ===

$88734684504266* Rotates the bits of an input left
$83642246004160* Rotate left


=== trans/manual_text_edit_instructions ===

$75786562031150*
After you complete the level "Turing Complete" the instruction panel allows you to manually edit instructions. This is useful if you wish to build your own computers.

If you just finished the OVERTURE computer and see something weird, odds are you may have changed the definitions.

Each row has a label and 8 bits you can set to either[img]dialogue/on.png[/img], [img]dialogue/off.png[/img] or [img]dialogue/any.png[/img] (wildcard). When using the instruction panel, if the bitpattern matches a row, the label will be shown.


=== trans/options_setting_export_assembled ===

$98549046707456* Export assembled binary


=== components/Bidirectional1 ===

$95836352586032* Can circumvent certain circular dependency errors
$34912798641933* 1 bit bidirectional pin


=== trans/odd_number_error ===

$61530231182650* Too many components used


=== components/Halt ===

$30351143139905* Halt

#  This is the default message of the Halt component
$54106972240596* Halt
$62990744955549* Stops execution with a custom message


=== misc/program_edit ===

$57861256694537* Bytes {bytes_from} - {bytes_to}


=== components/Bidirectional32 ===

$54631386552063* 32 bit bidirectional pin
$35105566244017* Can circumvent certain circular dependency errors


=== trans/level_wide_instructions_description ===

$60538893544456* [center]Build a wide instruction program component[/center]


=== trans/ide_assembly_codes ===

$62016169253008*
[center]Assembly
codes[/center]


=== misc/specifications ===

$56390619785555* View instructions definitions
$68054407020318* Instructions


=== trans/manual_component_factory_text ===

$42847481618884*
Open the component factory by clicking on this button [img]dialogue/manual/component_factory_icon.png[/img] in the upper left bar.

The component factory allows you to create your own components. The logic you place determine the behavior of the custom component and the layout determines the shape. 

The input and output components you place become pins on the component. Like with other components, a component output leading back to its input causes a circular dependency. Outputs having a path back to inputs causes a circular dependency for custom components, even if the insides of the component would suggest there shouldn't be one. Not having to worry about the inside of components reduces the complexity of larger builds, however this strict abstraction can be inconvenient under certain circumstances. In that case, use the unbuffered pins. They allow bidirectional flow and use the insides of the component to check for circular dependencies.

Probes placed in custom components will show on their layout and can display values inside. Probes can be connected to other custom components, so that deeply nested values can be displayed. Values probed in this way can also be connected to the program component.

For the component factory, the file manager also manages the custom components. The file names decide the component name and the folder structure decides the components placement in the menu.


=== levels/binary_start ===

$19099025738142* Start


=== trans/level_complete_stat_delay ===

$43118901497406* Delay


=== trans/level_byte_adder_you_carry_text2 ===

$87943759248740* Carry


=== levels/negative_numbers/test ===

$64427417171037* Test


=== trans/manual_binary ===

$19098578855427* Binary


=== misc/controls2 ===

$38773676077206* Edit Instructions


=== trans/manual_edit_instructions ===

$86365051641280* Edit instructions


=== components/Input1_1B ===

$10517158300617* Level input
$57868504368581* Loads the input from levels


=== trans/manual_terminology ===

$13311390759928* Terminology


=== trans/manual_text_network ===

$70445160410129*
[b]Overview[/b]
The "Network" component gives you low level access to networking. In general you manipulate your network by sending the component [color=#e49f44]Requests[/color] and when update [color=#39aa49]Events[/color] return from the network they get queued up and you process them one at a time. To keep track of different simultaneous connections [color=#dd6576]Connection ID[/color]s are used.

These are the request types you can send to the component and their arguments:
[code]0[/code] No request
[code]1[/code] [color=#e49f44]Listen[/color] ([color=#dd6576]Port[/color])
[code]2[/code] [color=#e49f44]Connect[/color] ([color=#dd6576]IP[/color], [color=#dd6576]Port[/color])
[code]3[/code] [color=#e49f44]Send data[/color] ([color=#dd6576]Connection ID[/color], [color=#dd6576]Data[/color], [color=#dd6576]Data length[/color])
[code]4[/code] [color=#e49f44]Close[/color] ([color=#dd6576]Connection ID[/color])
[code]5[/code] [color=#e49f44]Read next event[/color]
[i]See component panel for which pin correspond to which argument.[/i]

Request types [color=#e49f44]Listen[/color] and [color=#e49f44]Connect[/color] outputs the [color=#dd6576]Connection ID[/color] of the new connection.

For 2 programs to [color=#e49f44]Send data[/color] to each other, one program must first [color=#e49f44]Listen[/color] (called a server) on a [color=#dd6576]Port[/color] and the other must then [color=#e49f44]Connect[/color] (called a client), using the [color=#dd6576]IP[/color] of the listening program and the [color=#dd6576]Port[/color] it selected. Once the connection is established, the server and client function exactly the same.

Notice an [color=#dd6576]IP[/color] is a 32 bit number, normally written as 4 bytes with dots in between (example: 127.0.0.1). In this simulator you reverse the order of the bytes, so 127.0.0.1 becomes 0x0100007F. 0x0100007F is always your computers loopback address and you can use this to connect programs running on the same computer.

You can detect when events happen on the network, by checking the "Next event type" pin. These are the event types:
[code]0[/code] No event
[code]1[/code] [color=#39aa49]Incoming connection[/color] ([color=#dd6576]Connection ID[/color], [color=#dd6576]Port[/color])
[code]2[/code] [color=#39aa49]Connect complete[/color]
[code]3[/code] [color=#39aa49]Receive data[/color] ([color=#dd6576]Connection ID, Data[/color], [color=#dd6576]Data length[/color])
[code]4[/code] [color=#39aa49]Connection closed[/color] ([color=#dd6576]Connection ID[/color] / [color=#dd6576]Error code[/color])

[color=#39aa49]Incoming connection[/color] only happens after a [color=#e49f44]Listen[/color]. Use the [color=#dd6576]Port[/color] to distinguish between listeners (it is not possible to listen to the same port twice at the same time).

[color=#39aa49]Connect complete[/color] only happens after a [color=#e49f44]Connect[/color], wait for this before you start sending data.

You may send or receive between 1 and 8 bytes of data at a time, use the [color=#dd6576]Data length[/color] to decide.

A connection may be either "possibly open" or "closed". There is no way to know if a connection is actually open other than sending data. The underlying network protocols were designed like this for reliability and speed, it is not a limitation of the simulator.

If you get a [color=#dd6576]Connection ID[/color] of -1, this means there was an error connecting.


=== components/NetworkClient ===

$44510554000571* Network
$90462653419289* Handles network connections


=== levels/unseen_fruit ===

$13023474026617*
The most noteworthy thing on your planet is the fruit. It is very tasty.

That's why we are having a fruit tasting event in the canteen.
$14259900563789* Scan the conveyor belt for the fruit incoming at regular intervals. As soon as you have see the same kind of fruit twice, turn and press the control panel.


=== levels/conditions ===

$16742265812068* Regardless of VALUE output [img]dialogue/on.png[/img]
$12429396872036* Regardless of VALUE output [img]dialogue/off.png[/img]


=== trans/levels_negative_descriptions ===

$87964635915702*
-127 to 127 representable:
0 to 127 same as before:
Works with adder:


=== components/ByteShl ===

$74488427658653* Shift left
$66482114876737* Shifts the bits of an input left


=== trans/manual_instructions ===

$90323246286028* Instructions


=== trans/schematics_description ===

$39347262933523* Description


=== trans/level_component_factory_error ===

$49014901714855* Map squares can only contain one input or output node.


=== trans/level_ram_component_RichTextLabel2 ===

$92123299522120* [center]Expected states[/center]


=== components/MemoryProbe ===

$46948613505134* Display a value on your custom component or in the program editor
$44867305035474* Memory Probe


=== trans/options_working ===

$18749833316380* Working


=== components/Byte Expander ===

$60488114435022* Splits a byte into 8 bits
$21904470559153* Byte Splitter


=== trans/manual_text_rgb ===

$52915933943906*
This simulator uses 3 byte RGB colors for some components. Color are 1 byte each, the byte value determining the intensity of each color: 
[color=#e3243f]RRRRRRRR[/color][color=#55ff55]GGGGGGGG[/color][color=#3333ff]BBBBBBBB[/color]


=== misc/StateProbe ===

$54427436420428* Wire Probe
$15969687819995* Display a value on your custom component or in the program editor


=== components/Splitter32 ===

$90978982016052* Splits 32 bits into 4 bytes
$24096666569346* 32 bit Splitter


=== misc/instruciton_rule_label ===

$70464083627337* Label


=== trans/level_alu1_code ===

$20619700446604* [center]OR[/center]


=== components/Shl32 ===

$38930281262898* Shift left
$88685329847417* Shifts the bits of an input left


=== components/Shl64 ===

$56766765894165* Shifts the bits of an input left
$37014604954362* Shift left


=== trans/complete_unlocks ===

$45250062735373* Unlocks


=== components/DivMod8 ===

$37666366877853* Divide and mod 2 numbers
$44959426271423* Divide


=== trans/level_byte_mux_description ===

$20538476756633* [center]Output the correct input byte[/center]


=== levels/sr_latch ===

$11150103897185*
In this level, components may depend on themselves or form loops of up to two components. Despite depending on their own output, some of these wires have stable outputs, at least for some inputs.

The circuit you are asked to construct here has a circular dependency. The circuit also has 2 "stable states" for most inputs. A stable state here means that every component's output agrees with its input. As an example, an OR gate with one input disconnected and the other connected to its own output is stable. If the output is [OFF], both inputs are [OFF], which agrees with the OR gate. If the output is [ON], then so is one of the inputs. However, a NOT gate connected to its own input is not stable. If the output is [ON], then the input is [ON] as well. This will cause the NOT gate to try and make the output [OFF], which will also make the input [OFF]. The circuit will switch between these two states forever, so it is not stable.
$18165461234561* Delay lines are easy to understand and can be used to build any computer architecture. However, modern hardware no longer use these as a basis for memory.


=== trans/level_program_description ===

$44017405175202* [center]Replace the input code with the program component.[/center]


=== trans/manual_program ===

$91120798735036* Program


=== levels/Immediate Values ===

$64348543296709* Linked component {value} should point to the output
$14060810229477* Add 6 registers to the map
$79667526283284* Linked component {value} should point to the counter
$14960344494328*
Sometimes it is useful to load a value directly from the program instead of from registers. This is called loading an immediate value. In the [color=#e49f44]LEG[/color] architecture we signal when we want to do this directly in the opcode. We can do that in the following way:
	
When the 8th bit of the opcode is [ON], use argument 1 as an immediate value, instead of as a register address.
When the 7th bit of the opcode is [ON], use argument 2 as an immediate value, instead of as a register address.
	
		[img]dialogue/leg_diagram.png[/img]
		
$10788301006338* Linked component {nr} should point to a register or custom component with a register inside
$19338533633006* Set the counter increment to 4
$15197362332657* Create a new schematic and add a program with 4 byte output
$10141611261952* [center]Implement immediate values[/center]


=== levels/xor ===

$12758156517177* Using the instructions of your computer, read the input twice and XOR the two values together
$16047615798435* [center]Read the input twice and XOR the bits of the two inputs[/center]


=== trans/manual_simulator ===

$19932404521621* Simulator


=== levels/Wire Spaghetti ===

$18860645759682*
The [color=#e49f44]LEG[/color] architecture is a computer that takes 4 bytes per tick from the program. 

The first byte describes the operation (called the [color=#e49f44]OPCODE[/color]).

Since many operations take 2 arguments (like ADD, OR etc), the second and third byte are for arguments.

And since most operations return 1 result, the fourth byte is for the result.
	
	[img]dialogue/leg_diagram_1.png[/img]
$14051336765362* Finally it is time for you to start building the [color=#e49f44]LEG[/color] architecture!
$13268807052125* (You might be adding 7+7, but here 7 means load from input and the input has value 8)
$30006055126224* Linked component {output} should point to the output
$19066122929275* [center]Set up registers and implement the ADD opcode[/center]
$10912834168905*
Finally, in this level the [color=#e49f44]OPCODE[/color] is always 0. This means we ADD argument 1 and argument 2 and save the result to the destination.

The value of an argument or destination refers to one of these places:
[code]
[color=#e49f44]0[/color]: Register 0
[color=#e49f44]1[/color]: Register 1
[color=#e49f44]2[/color]: Register 2
[color=#e49f44]3[/color]: Register 3
[color=#e49f44]4[/color]: Register 4
[color=#e49f44]5[/color]: Register 5
[color=#e49f44]6[/color]: Counter
[color=#e49f44]7[/color]: Input/Output
[/code]

In the next level you will implement more [color=#e49f44]OPCODES[/color], which will require a different ALU than that of [color=#e49f44]OVERTURE[/color].
$18769284297247* Create a new schematic and add a program with 4 byte output


=== trans/level_dependency_description ===

$81238724438578* Make a wire where the input of a component depends on its own output


=== levels/the_bus ===

$96958133516462* FROM
$91318587712792* TO


=== components/DivMod16 ===

$42657221816637* Divide and mod 2 numbers
$22319923069746* Divide


